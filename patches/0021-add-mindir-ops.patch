From 881a1c16aeac375bb92d32e80d70239694d0b34b Mon Sep 17 00:00:00 2001
From: chengfeng27 <chengfeng27@huawei.com>
Date: Wed, 5 Jun 2024 19:33:58 +0800
Subject: fix MindIR_ScatterElements_CreatePrimitive

---
 mindspore/lite/mindir/BUILD.gn                |    2 +
 mindspore/lite/mindir/include/mindir.h        |  406 ++++
 mindspore/lite/mindir/include/mindir_tensor.h |    1 +
 mindspore/lite/mindir/include/mindir_types.h  |   60 +
 mindspore/lite/mindir/src/mindir.cc           |  106 +-
 mindspore/lite/mindir/src/mindir_1.cc         | 2061 ++++++++++++++++
 mindspore/lite/mindir/src/mindir_2.cc         | 2152 +++++++++++++++++
 mindspore/lite/mindir/src/mindir_tensor.cc    |   13 +
 8 files changed, 4797 insertions(+), 4 deletions(-)
 create mode 100644 mindspore/lite/mindir/src/mindir_1.cc
 create mode 100644 mindspore/lite/mindir/src/mindir_2.cc

diff --git a/mindspore/lite/mindir/BUILD.gn b/mindspore/lite/mindir/BUILD.gn
index ad4eff84..ec87d1da 100644
--- a/mindspore/lite/mindir/BUILD.gn
+++ b/mindspore/lite/mindir/BUILD.gn
@@ -38,6 +38,8 @@ ohos_shared_library("mindir_lib") {
   sources = [
     "../src/common/log.cc",
     "src/mindir.cc",
+    "src/mindir_1.cc",
+    "src/mindir_2.cc",
     "src/mindir_memory_manager.cc",
     "src/mindir_nnrt_lite_graph.cc",
     "src/mindir_tensor.cc",
diff --git a/mindspore/lite/mindir/include/mindir.h b/mindspore/lite/mindir/include/mindir.h
index 7eb3a744..d236b6cc 100644
--- a/mindspore/lite/mindir/include/mindir.h
+++ b/mindspore/lite/mindir/include/mindir.h
@@ -666,6 +666,412 @@ PrimitivePtr MindIR_Rank_CreatePrimitive();
 // ********** GatherNd **********
 PrimitivePtr MindIR_GatherNd_CreatePrimitive();
 
+// ********** BatchToSpace **********
+PrimitivePtr MindIR_BatchToSpace_CreatePrimitive(const std::vector<int64_t>& block_size, const std::vector<std::vector<int64_t>>& crops);
+std::vector<int64_t> MindIR_BatchToSpace_GetBlockSize(ConstPrimitivePtr primitive);
+void MindIR_BatchToSpace_SetBlockSize(PrimitivePtr *primitive, const std::vector<int64_t>& block_size);
+std::vector<std::vector<int64_t>> MindIR_BatchToSpace_GetCrops(ConstPrimitivePtr primitive);
+void MindIR_BatchToSpace_SetCrops(PrimitivePtr *primitive, const std::vector<std::vector<int64_t>>& crops);
+
+// ********** Depend **********
+PrimitivePtr MindIR_Depend_CreatePrimitive();
+
+// ********** Dropout **********
+PrimitivePtr MindIR_Dropout_CreatePrimitive(float keep_prob);
+float MindIR_Dropout_GetKeepProb(ConstPrimitivePtr primitive);
+void MindIR_Dropout_SetKeepProb(PrimitivePtr *primitive, float keep_prob);
+
+// ********** Elu **********
+PrimitivePtr MindIR_Elu_CreatePrimitive(float alpha);
+float MindIR_Elu_GetAlpha(ConstPrimitivePtr primitive);
+void MindIR_Elu_SetAlpha(PrimitivePtr *primitive, float alpha);
+
+// ********** EmbeddingLookupFusion **********
+PrimitivePtr MindIR_EmbeddingLookupFusion_CreatePrimitive(float max_norm);
+float MindIR_EmbeddingLookupFusion_GetMaxNorm(ConstPrimitivePtr primitive);
+void MindIR_EmbeddingLookupFusion_SetMaxNorm(PrimitivePtr *primitive, float max_norm);
+
+// ********** FakeQuantWithMinMaxVars **********
+PrimitivePtr MindIR_FakeQuantWithMinMaxVars_CreatePrimitive(int64_t num_bits, bool narrow_range);
+int64_t MindIR_FakeQuantWithMinMaxVars_GetNumBits(ConstPrimitivePtr primitive);
+void MindIR_FakeQuantWithMinMaxVars_SetNumBits(PrimitivePtr *primitive, int64_t num_bits);
+bool MindIR_FakeQuantWithMinMaxVars_GetNarrowRange(ConstPrimitivePtr primitive);
+void MindIR_FakeQuantWithMinMaxVars_SetNarrowRange(PrimitivePtr *primitive, bool narrow_range);
+
+// ********** FakeQuantWithMinMaxVarsPerChannel **********
+PrimitivePtr MindIR_FakeQuantWithMinMaxVarsPerChannel_CreatePrimitive(int64_t num_bits, bool narrow_range);
+int64_t MindIR_FakeQuantWithMinMaxVarsPerChannel_GetNumBits(ConstPrimitivePtr primitive);
+void MindIR_FakeQuantWithMinMaxVarsPerChannel_SetNumBits(PrimitivePtr *primitive, int64_t num_bits);
+bool MindIR_FakeQuantWithMinMaxVarsPerChannel_GetNarrowRange(ConstPrimitivePtr primitive);
+void MindIR_FakeQuantWithMinMaxVarsPerChannel_SetNarrowRange(PrimitivePtr *primitive, bool narrow_range);
+
+// ********** FftReal **********
+PrimitivePtr MindIR_FftReal_CreatePrimitive();
+
+// ********** FftImag **********
+PrimitivePtr MindIR_FftImag_CreatePrimitive();
+
+// ********** FloorDiv **********
+PrimitivePtr MindIR_FloorDiv_CreatePrimitive();
+
+// ********** FloorMod **********
+PrimitivePtr MindIR_FloorMod_CreatePrimitive();
+
+// ********** HashtableLookup **********
+PrimitivePtr MindIR_HashtableLookup_CreatePrimitive();
+
+// ********** LpNormalization **********
+PrimitivePtr MindIR_LpNormalization_CreatePrimitive(int64_t axis, int64_t p);
+int64_t MindIR_LpNormalization_GetAxis(ConstPrimitivePtr primitive);
+void MindIR_LpNormalization_SetAxis(PrimitivePtr *primitive, int64_t axis);
+int64_t MindIR_LpNormalization_GetP(ConstPrimitivePtr primitive);
+void MindIR_LpNormalization_SetP(PrimitivePtr *primitive, int64_t p);
+
+// ********** LshProjection **********
+PrimitivePtr MindIR_LshProjection_CreatePrimitive(LshProjectionType type);
+LshProjectionType MindIR_LshProjection_GetType(ConstPrimitivePtr primitive);
+void MindIR_LshProjection_SetType(PrimitivePtr *primitive, LshProjectionType type);
+
+// ********** SwitchLayer **********
+PrimitivePtr MindIR_SwitchLayer_CreatePrimitive();
+
+// ********** Mfcc **********
+PrimitivePtr MindIR_Mfcc_CreatePrimitive(float freq_upper_limit, float freq_lower_limit, int64_t filter_bank_channel_num, int64_t dct_coeff_num);
+float MindIR_Mfcc_GetFreqUpperLimit(ConstPrimitivePtr primitive);
+void MindIR_Mfcc_SetFreqUpperLimit(PrimitivePtr *primitive, float freq_upper_limit);
+float MindIR_Mfcc_GetFreqLowerLimit(ConstPrimitivePtr primitive);
+void MindIR_Mfcc_SetFreqLowerLimit(PrimitivePtr *primitive, float freq_lower_limit);
+int64_t MindIR_Mfcc_GetFilterBankChannelNum(ConstPrimitivePtr primitive);
+void MindIR_Mfcc_SetFilterBankChannelNum(PrimitivePtr *primitive, int64_t filter_bank_channel_num);
+int64_t MindIR_Mfcc_GetDctCoeffNum(ConstPrimitivePtr primitive);
+void MindIR_Mfcc_SetDctCoeffNum(PrimitivePtr *primitive, int64_t dct_coeff_num);
+
+// ********** NonMaxSuppression **********
+PrimitivePtr MindIR_NonMaxSuppression_CreatePrimitive(int64_t center_point_box);
+int64_t MindIR_NonMaxSuppression_GetCenterPointBox(ConstPrimitivePtr primitive);
+void MindIR_NonMaxSuppression_SetCenterPointBox(PrimitivePtr *primitive, int64_t center_point_box);
+
+// ********** OnesLike **********
+PrimitivePtr MindIR_OnesLike_CreatePrimitive();
+
+// ********** PartialFusion **********
+PrimitivePtr MindIR_PartialFusion_CreatePrimitive(int64_t sub_graph_index);
+int64_t MindIR_PartialFusion_GetSubGraphIndex(ConstPrimitivePtr primitive);
+void MindIR_PartialFusion_SetSubGraphIndex(PrimitivePtr *primitive, int64_t sub_graph_index);
+
+// ********** PriorBox **********
+PrimitivePtr MindIR_PriorBox_CreatePrimitive(const std::vector<int64_t>& min_sizes, const std::vector<int64_t>& max_sizes, const std::vector<float>& aspect_ratios, const std::vector<float>& variances, int64_t image_size_w, int64_t image_size_h, float step_w, float step_h, bool clip, bool flip, float offset);
+std::vector<int64_t> MindIR_PriorBox_GetMinSizes(ConstPrimitivePtr primitive);
+void MindIR_PriorBox_SetMinSizes(PrimitivePtr *primitive, const std::vector<int64_t>& min_sizes);
+std::vector<int64_t> MindIR_PriorBox_GetMaxSizes(ConstPrimitivePtr primitive);
+void MindIR_PriorBox_SetMaxSizes(PrimitivePtr *primitive, const std::vector<int64_t>& max_sizes);
+std::vector<float> MindIR_PriorBox_GetAspectRatios(ConstPrimitivePtr primitive);
+void MindIR_PriorBox_SetAspectRatios(PrimitivePtr *primitive, const std::vector<float>& aspect_ratios);
+std::vector<float> MindIR_PriorBox_GetVariances(ConstPrimitivePtr primitive);
+void MindIR_PriorBox_SetVariances(PrimitivePtr *primitive, const std::vector<float>& variances);
+int64_t MindIR_PriorBox_GetImageSizeW(ConstPrimitivePtr primitive);
+void MindIR_PriorBox_SetImageSizeW(PrimitivePtr *primitive, int64_t image_size_w);
+int64_t MindIR_PriorBox_GetImageSizeH(ConstPrimitivePtr primitive);
+void MindIR_PriorBox_SetImageSizeH(PrimitivePtr *primitive, int64_t image_size_h);
+float MindIR_PriorBox_GetStepW(ConstPrimitivePtr primitive);
+void MindIR_PriorBox_SetStepW(PrimitivePtr *primitive, float step_w);
+float MindIR_PriorBox_GetStepH(ConstPrimitivePtr primitive);
+void MindIR_PriorBox_SetStepH(PrimitivePtr *primitive, float step_h);
+bool MindIR_PriorBox_GetClip(ConstPrimitivePtr primitive);
+void MindIR_PriorBox_SetClip(PrimitivePtr *primitive, bool clip);
+bool MindIR_PriorBox_GetFlip(ConstPrimitivePtr primitive);
+void MindIR_PriorBox_SetFlip(PrimitivePtr *primitive, bool flip);
+float MindIR_PriorBox_GetOffset(ConstPrimitivePtr primitive);
+void MindIR_PriorBox_SetOffset(PrimitivePtr *primitive, float offset);
+
+// ********** ReverseSequence **********
+PrimitivePtr MindIR_ReverseSequence_CreatePrimitive(int64_t seq_dim, int64_t batch_dim);
+int64_t MindIR_ReverseSequence_GetSeqDim(ConstPrimitivePtr primitive);
+void MindIR_ReverseSequence_SetSeqDim(PrimitivePtr *primitive, int64_t seq_dim);
+int64_t MindIR_ReverseSequence_GetBatchDim(ConstPrimitivePtr primitive);
+void MindIR_ReverseSequence_SetBatchDim(PrimitivePtr *primitive, int64_t batch_dim);
+
+// ********** ReverseV2 **********
+PrimitivePtr MindIR_ReverseV2_CreatePrimitive(const std::vector<int64_t>& axis);
+std::vector<int64_t> MindIR_ReverseV2_GetAxis(ConstPrimitivePtr primitive);
+void MindIR_ReverseV2_SetAxis(PrimitivePtr *primitive, const std::vector<int64_t>& axis);
+
+// ********** Rfft **********
+PrimitivePtr MindIR_Rfft_CreatePrimitive(int64_t fft_length);
+int64_t MindIR_Rfft_GetFftLength(ConstPrimitivePtr primitive);
+void MindIR_Rfft_SetFftLength(PrimitivePtr *primitive, int64_t fft_length);
+
+// ********** ROIPooling **********
+PrimitivePtr MindIR_ROIPooling_CreatePrimitive(int64_t pooled_h, int64_t pooled_w, float scale);
+int64_t MindIR_ROIPooling_GetPooledH(ConstPrimitivePtr primitive);
+void MindIR_ROIPooling_SetPooledH(PrimitivePtr *primitive, int64_t pooled_h);
+int64_t MindIR_ROIPooling_GetPooledW(ConstPrimitivePtr primitive);
+void MindIR_ROIPooling_SetPooledW(PrimitivePtr *primitive, int64_t pooled_w);
+float MindIR_ROIPooling_GetScale(ConstPrimitivePtr primitive);
+void MindIR_ROIPooling_SetScale(PrimitivePtr *primitive, float scale);
+
+// ********** SkipGram **********
+PrimitivePtr MindIR_SkipGram_CreatePrimitive(bool include_all_grams, int64_t max_skip_size, int64_t ngram_size);
+bool MindIR_SkipGram_GetIncludeAllGrams(ConstPrimitivePtr primitive);
+void MindIR_SkipGram_SetIncludeAllGrams(PrimitivePtr *primitive, bool include_all_grams);
+int64_t MindIR_SkipGram_GetMaxSkipSize(ConstPrimitivePtr primitive);
+void MindIR_SkipGram_SetMaxSkipSize(PrimitivePtr *primitive, int64_t max_skip_size);
+int64_t MindIR_SkipGram_GetNgramSize(ConstPrimitivePtr primitive);
+void MindIR_SkipGram_SetNgramSize(PrimitivePtr *primitive, int64_t ngram_size);
+
+// ********** Switch **********
+PrimitivePtr MindIR_Switch_CreatePrimitive();
+
+// ********** Unique **********
+PrimitivePtr MindIR_Unique_CreatePrimitive();
+
+// ********** UnsortedSegmentSum **********
+PrimitivePtr MindIR_UnsortedSegmentSum_CreatePrimitive();
+
+// ********** ZerosLike **********
+PrimitivePtr MindIR_ZerosLike_CreatePrimitive();
+
+// ********** GRU **********
+PrimitivePtr MindIR_GRU_CreatePrimitive( bool bidirectional);
+bool MindIR_GRU_GetBidirectional(ConstPrimitivePtr primitive);
+void MindIR_GRU_SetBidirectional(PrimitivePtr *primitive, bool bidirectional);
+
+// ********** NonZero **********
+PrimitivePtr MindIR_NonZero_CreatePrimitive();
+
+// ********** InvertPermutation **********
+PrimitivePtr MindIR_InvertPermutation_CreatePrimitive();
+
+// ********** Size **********
+PrimitivePtr MindIR_Size_CreatePrimitive();
+
+// ********** RandomStandardNormal **********
+PrimitivePtr MindIR_RandomStandardNormal_CreatePrimitive(int64_t seed, int64_t seed2);
+int64_t MindIR_RandomStandardNormal_GetSeed(ConstPrimitivePtr primitive);
+void MindIR_RandomStandardNormal_SetSeed(PrimitivePtr *primitive, int64_t seed);
+int64_t MindIR_RandomStandardNormal_GetSeed2(ConstPrimitivePtr primitive);
+void MindIR_RandomStandardNormal_SetSeed2(PrimitivePtr *primitive, int64_t seed2);
+
+// ********** CropAndResize **********
+PrimitivePtr MindIR_CropAndResize_CreatePrimitive(ResizeMethod method, float extrapolation_value);
+ResizeMethod MindIR_CropAndResize_GetMethod(ConstPrimitivePtr primitive);
+void MindIR_CropAndResize_SetMethod(PrimitivePtr *primitive, ResizeMethod method);
+float MindIR_CropAndResize_GetExtrapolationValue(ConstPrimitivePtr primitive);
+void MindIR_CropAndResize_SetExtrapolationValue(PrimitivePtr *primitive, float extrapolation_value);
+
+// ********** IsFinite **********
+PrimitivePtr MindIR_IsFinite_CreatePrimitive();
+
+// ********** LinSpace **********
+PrimitivePtr MindIR_LinSpace_CreatePrimitive();
+
+// ********** UniformReal **********
+PrimitivePtr MindIR_UniformReal_CreatePrimitive(int64_t seed, int64_t seed2);
+int64_t MindIR_UniformReal_GetSeed(ConstPrimitivePtr primitive);
+void MindIR_UniformReal_SetSeed(PrimitivePtr *primitive, int64_t seed);
+int64_t MindIR_UniformReal_GetSeed2(ConstPrimitivePtr primitive);
+void MindIR_UniformReal_SetSeed2(PrimitivePtr *primitive, int64_t seed2);
+
+// ********** Splice **********
+PrimitivePtr MindIR_Splice_CreatePrimitive(const std::vector<int64_t>& context, const std::vector<int64_t>& forward_indexes, int64_t output_dim);
+std::vector<int64_t> MindIR_Splice_GetContext(ConstPrimitivePtr primitive);
+void MindIR_Splice_SetContext(PrimitivePtr *primitive, const std::vector<int64_t>& context);
+std::vector<int64_t> MindIR_Splice_GetForwardIndexes(ConstPrimitivePtr primitive);
+void MindIR_Splice_SetForwardIndexes(PrimitivePtr *primitive, const std::vector<int64_t>& forward_indexes);
+int64_t MindIR_Splice_GetOutputDim(ConstPrimitivePtr primitive);
+void MindIR_Splice_SetOutputDim(PrimitivePtr *primitive, int64_t output_dim);
+
+// ********** Call **********
+PrimitivePtr MindIR_Call_CreatePrimitive(bool is_tail_call);
+bool MindIR_Call_GetIsTailCall(ConstPrimitivePtr primitive);
+void MindIR_Call_SetIsTailCall(PrimitivePtr *primitive, bool is_tail_call);
+
+// ********** CumSum **********
+PrimitivePtr MindIR_CumSum_CreatePrimitive(bool exclusive, bool reverse);
+bool MindIR_CumSum_GetExclusive(ConstPrimitivePtr primitive);
+void MindIR_CumSum_SetExclusive(PrimitivePtr *primitive, bool exclusive);
+bool MindIR_CumSum_GetReverse(ConstPrimitivePtr primitive);
+void MindIR_CumSum_SetReverse(PrimitivePtr *primitive, bool reverse);
+
+// ********** SplitWithOverlap **********
+PrimitivePtr MindIR_SplitWithOverlap_CreatePrimitive(int64_t split_dim, int64_t number_split, const std::vector<int64_t>& ratio, const std::vector<int64_t>& extend_top, const std::vector<int64_t>& extend_bottom);
+int64_t MindIR_SplitWithOverlap_GetSplitDim(ConstPrimitivePtr primitive);
+void MindIR_SplitWithOverlap_SetSplitDim(PrimitivePtr *primitive, int64_t split_dim);
+int64_t MindIR_SplitWithOverlap_GetNumberSplit(ConstPrimitivePtr primitive);
+void MindIR_SplitWithOverlap_SetNumberSplit(PrimitivePtr *primitive, int64_t number_split);
+std::vector<int64_t> MindIR_SplitWithOverlap_GetRatio(ConstPrimitivePtr primitive);
+void MindIR_SplitWithOverlap_SetRatio(PrimitivePtr *primitive, const std::vector<int64_t>& ratio);
+std::vector<int64_t> MindIR_SplitWithOverlap_GetExtendTop(ConstPrimitivePtr primitive);
+void MindIR_SplitWithOverlap_SetExtendTop(PrimitivePtr *primitive, const std::vector<int64_t>& extend_top);
+std::vector<int64_t> MindIR_SplitWithOverlap_GetExtendBottom(ConstPrimitivePtr primitive);
+void MindIR_SplitWithOverlap_SetExtendBottom(PrimitivePtr *primitive, const std::vector<int64_t>& extend_bottom);
+
+// ********** GenOP **********
+PrimitivePtr MindIR_GenOP_CreatePrimitive(ActivationType activation_type, float alpha, float min_val, float max_val, bool is_training, Format format, const std::vector<int64_t>& kernel_size, const std::vector<int64_t>& stride, const std::vector<int64_t>& dilation, PadMode pad_mode, const std::vector<int64_t>& pad_list, int64_t mode, int64_t group, int64_t in_channel, int64_t out_channel, EltwiseMode eltwise_mode, bool has_bias, bool use_axis, int64_t axis, float epsilon, float momentum, bool transpose_a, bool transpose_b, const std::vector<int64_t>& pad, RoundMode round_mode, bool global, bool channel_shared, const std::vector<int64_t>& axes, bool keep_dims, ReduceMode reduce_mode, bool reduce_to_end, float coeff);
+ActivationType MindIR_GenOP_GetActivationType(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetActivationType(PrimitivePtr *primitive, ActivationType activation_type);
+float MindIR_GenOP_GetAlpha(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetAlpha(PrimitivePtr *primitive, float alpha);
+float MindIR_GenOP_GetMinVal(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetMinVal(PrimitivePtr *primitive, float min_val);
+float MindIR_GenOP_GetMaxVal(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetMaxVal(PrimitivePtr *primitive, float max_val);
+bool MindIR_GenOP_GetIsTraining(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetIsTraining(PrimitivePtr *primitive, bool is_training);
+Format MindIR_GenOP_GetFormat(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetFormat(PrimitivePtr *primitive, Format format);
+std::vector<int64_t> MindIR_GenOP_GetKernelSize(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetKernelSize(PrimitivePtr *primitive, const std::vector<int64_t>& kernel_size);
+std::vector<int64_t> MindIR_GenOP_GetStride(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetStride(PrimitivePtr *primitive, const std::vector<int64_t>& stride);
+std::vector<int64_t> MindIR_GenOP_GetDilation(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetDilation(PrimitivePtr *primitive, const std::vector<int64_t>& dilation);
+PadMode MindIR_GenOP_GetPadMode(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetPadMode(PrimitivePtr *primitive, PadMode pad_mode);
+std::vector<int64_t> MindIR_GenOP_GetPadList(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetPadList(PrimitivePtr *primitive, const std::vector<int64_t>& pad_list);
+int64_t MindIR_GenOP_GetMode(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetMode(PrimitivePtr *primitive, int64_t mode);
+int64_t MindIR_GenOP_GetGroup(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetGroup(PrimitivePtr *primitive, int64_t group);
+int64_t MindIR_GenOP_GetInChannel(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetInChannel(PrimitivePtr *primitive, int64_t in_channel);
+int64_t MindIR_GenOP_GetOutChannel(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetOutChannel(PrimitivePtr *primitive, int64_t out_channel);
+EltwiseMode MindIR_GenOP_GetEltwiseMode(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetEltwiseMode(PrimitivePtr *primitive, EltwiseMode eltwise_mode);
+bool MindIR_GenOP_GetHasBias(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetHasBias(PrimitivePtr *primitive, bool has_bias);
+bool MindIR_GenOP_GetUseAxis(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetUseAxis(PrimitivePtr *primitive, bool use_axis);
+int64_t MindIR_GenOP_GetAxis(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetAxis(PrimitivePtr *primitive, int64_t axis);
+float MindIR_GenOP_GetEpsilon(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetEpsilon(PrimitivePtr *primitive, float epsilon);
+float MindIR_GenOP_GetMomentum(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetMomentum(PrimitivePtr *primitive, float momentum);
+bool MindIR_GenOP_GetTransposeA(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetTransposeA(PrimitivePtr *primitive, bool transpose_a);
+bool MindIR_GenOP_GetTransposeB(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetTransposeB(PrimitivePtr *primitive, bool transpose_b);
+std::vector<int64_t> MindIR_GenOP_GetPad(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetPad(PrimitivePtr *primitive, const std::vector<int64_t>& pad);
+RoundMode MindIR_GenOP_GetRoundMode(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetRoundMode(PrimitivePtr *primitive, RoundMode round_mode);
+bool MindIR_GenOP_GetGlobal(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetGlobal(PrimitivePtr *primitive, bool global);
+bool MindIR_GenOP_GetChannelShared(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetChannelShared(PrimitivePtr *primitive, bool channel_shared);
+std::vector<int64_t> MindIR_GenOP_GetAxes(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetAxes(PrimitivePtr *primitive, const std::vector<int64_t>& axes);
+bool MindIR_GenOP_GetKeepDims(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetKeepDims(PrimitivePtr *primitive, bool keep_dims);
+ReduceMode MindIR_GenOP_GetReduceMode(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetReduceMode(PrimitivePtr *primitive, ReduceMode reduce_mode);
+bool MindIR_GenOP_GetReduceToEnd(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetReduceToEnd(PrimitivePtr *primitive, bool reduce_to_end);
+float MindIR_GenOP_GetCoeff(ConstPrimitivePtr primitive);
+void MindIR_GenOP_SetCoeff(PrimitivePtr *primitive, float coeff);
+
+// ********** RaggedRange **********
+PrimitivePtr MindIR_RaggedRange_CreatePrimitive();
+
+// ********** GLU **********
+PrimitivePtr MindIR_GLU_CreatePrimitive(int64_t axis);
+int64_t MindIR_GLU_GetAxis(ConstPrimitivePtr primitive);
+void MindIR_GLU_SetAxis(PrimitivePtr *primitive, int64_t axis);
+
+// ********** Affine **********
+PrimitivePtr MindIR_Affine_CreatePrimitive(const std::vector<int64_t>& context, int64_t output_dim, ActivationType activation_type, bool transpose_a, bool transpose_b);
+std::vector<int64_t> MindIR_Affine_GetContext(ConstPrimitivePtr primitive);
+void MindIR_Affine_SetContext(PrimitivePtr *primitive, const std::vector<int64_t>& context);
+int64_t MindIR_Affine_GetOutputDim(ConstPrimitivePtr primitive);
+void MindIR_Affine_SetOutputDim(PrimitivePtr *primitive, int64_t output_dim);
+ActivationType MindIR_Affine_GetActivationType(ConstPrimitivePtr primitive);
+void MindIR_Affine_SetActivationType(PrimitivePtr *primitive, ActivationType activation_type);
+bool MindIR_Affine_GetTransposeA(ConstPrimitivePtr primitive);
+void MindIR_Affine_SetTransposeA(PrimitivePtr *primitive, bool transpose_a);
+bool MindIR_Affine_GetTransposeB(ConstPrimitivePtr primitive);
+void MindIR_Affine_SetTransposeB(PrimitivePtr *primitive, bool transpose_b);
+
+// ********** AllGather **********
+PrimitivePtr MindIR_AllGather_CreatePrimitive(const std::string& group, int32_t rank_size);
+std::string MindIR_AllGather_GetGroup(ConstPrimitivePtr primitive);
+void MindIR_AllGather_SetGroup(PrimitivePtr *primitive, const std::string& group);
+int32_t MindIR_AllGather_GetRankSize(ConstPrimitivePtr primitive);
+void MindIR_AllGather_SetRankSize(PrimitivePtr *primitive, int32_t rank_size);
+
+
+
+// ********** ReduceScatter **********
+PrimitivePtr MindIR_ReduceScatter_CreatePrimitive(const std::string& group, ReduceMode mode, int32_t rank_size);
+std::string MindIR_ReduceScatter_GetGroup(ConstPrimitivePtr primitive);
+void MindIR_ReduceScatter_SetGroup(PrimitivePtr *primitive, const std::string& group);
+ReduceMode MindIR_ReduceScatter_GetMode(ConstPrimitivePtr primitive);
+void MindIR_ReduceScatter_SetMode(PrimitivePtr *primitive, ReduceMode mode);
+int32_t MindIR_ReduceScatter_GetRankSize(ConstPrimitivePtr primitive);
+void MindIR_ReduceScatter_SetRankSize(PrimitivePtr *primitive, int32_t rank_size);
+
+
+
+// ********** DynamicQuant **********
+PrimitivePtr MindIR_DynamicQuant_CreatePrimitive(bool symmetric, int64_t dst_type);
+bool MindIR_DynamicQuant_GetSymmetric(ConstPrimitivePtr primitive);
+void MindIR_DynamicQuant_SetSymmetric(PrimitivePtr *primitive, bool symmetric);
+int64_t MindIR_DynamicQuant_GetDstType(ConstPrimitivePtr primitive);
+void MindIR_DynamicQuant_SetDstType(PrimitivePtr *primitive, int64_t dst_type);
+
+// ********** RandomNormal **********
+PrimitivePtr MindIR_RandomNormal_CreatePrimitive(float seed, float mean, float scale);
+float MindIR_RandomNormal_GetSeed(ConstPrimitivePtr primitive);
+void MindIR_RandomNormal_SetSeed(PrimitivePtr *primitive, float seed);
+float MindIR_RandomNormal_GetMean(ConstPrimitivePtr primitive);
+void MindIR_RandomNormal_SetMean(PrimitivePtr *primitive, float mean);
+float MindIR_RandomNormal_GetScale(ConstPrimitivePtr primitive);
+void MindIR_RandomNormal_SetScale(PrimitivePtr *primitive, float scale);
+
+// ********** FormatTranspose **********
+PrimitivePtr MindIR_FormatTranspose_CreatePrimitive(Format src_format, Format dst_format);
+Format MindIR_FormatTranspose_GetSrcFormat(ConstPrimitivePtr primitive);
+void MindIR_FormatTranspose_SetSrcFormat(PrimitivePtr *primitive, Format src_format);
+Format MindIR_FormatTranspose_GetDstFormat(ConstPrimitivePtr primitive);
+void MindIR_FormatTranspose_SetDstFormat(PrimitivePtr *primitive, Format dst_format);
+
+// ********** GatherD **********
+PrimitivePtr MindIR_GatherD_CreatePrimitive();
+
+// ********** GroupNormFusion **********
+PrimitivePtr MindIR_GroupNormFusion_CreatePrimitive(int64_t num_groups, float epsilon, bool affine);
+int64_t MindIR_GroupNormFusion_GetNumGroups(ConstPrimitivePtr primitive);
+void MindIR_GroupNormFusion_SetNumGroups(PrimitivePtr *primitive, int64_t num_groups);
+float MindIR_GroupNormFusion_GetEpsilon(ConstPrimitivePtr primitive);
+void MindIR_GroupNormFusion_SetEpsilon(PrimitivePtr *primitive, float epsilon);
+bool MindIR_GroupNormFusion_GetAffine(ConstPrimitivePtr primitive);
+void MindIR_GroupNormFusion_SetAffine(PrimitivePtr *primitive, bool affine);
+
+// ********** Log1p **********
+PrimitivePtr MindIR_Log1p_CreatePrimitive();
+
+// ********** SparseFillEmptyRows **********
+PrimitivePtr MindIR_SparseFillEmptyRows_CreatePrimitive();
+
+// ********** SparseReshape **********
+PrimitivePtr MindIR_SparseReshape_CreatePrimitive();
+
+// ********** SparseSegmentSum **********
+PrimitivePtr MindIR_SparseSegmentSum_CreatePrimitive();
+
+// ********** ScatterElements **********
+PrimitivePtr MindIR_ScatterElements_CreatePrimitive(int64_t axis);
+int64_t MindIR_ScatterElements_GetAxis(ConstPrimitivePtr primitive);
+void MindIR_ScatterElements_SetAxis(PrimitivePtr *primitive, int64_t axis);
+
+// ********** Triu **********
+PrimitivePtr MindIR_Triu_CreatePrimitive();
+
+// ********** Tril **********
+PrimitivePtr MindIR_Tril_CreatePrimitive();
+
 // ********** Custom **********
 std::vector<const mindspore::schema::Attribute *> MindIR_Custom_GetAttr(ConstPrimitivePtr primitive);
 std::string MindIR_Attribute_GetName(const mindspore::schema::Attribute &attr);
diff --git a/mindspore/lite/mindir/include/mindir_tensor.h b/mindspore/lite/mindir/include/mindir_tensor.h
index 43c1478c..d8b4aa37 100644
--- a/mindspore/lite/mindir/include/mindir_tensor.h
+++ b/mindspore/lite/mindir/include/mindir_tensor.h
@@ -23,6 +23,7 @@ void MindIR_Tensor_SetData(TensorPtr *tensor, const std::vector<uint8_t> &data);
 std::vector<uint8_t> MindIR_Tensor_GetData(ConstTensorPtr tensor);
 std::vector<QuantParam> MindIR_Tensor_GetQuantParams(ConstTensorPtr tensor);
 void MindIR_Tensor_SetQuantParams(TensorPtr *tensor, const std::vector<QuantParam> &quant_params);
+int32_t MindIR_Tensor_GetNodeType(ConstTensorPtr tensor);
 
 void MindIR_Tensor_Destroy(TensorPtr *tensor);
 
diff --git a/mindspore/lite/mindir/include/mindir_types.h b/mindspore/lite/mindir/include/mindir_types.h
index 196995fa..ec224b2c 100644
--- a/mindspore/lite/mindir/include/mindir_types.h
+++ b/mindspore/lite/mindir/include/mindir_types.h
@@ -84,6 +84,7 @@ enum NodeType : uint32_t {
   NODE_TYPE_ARGMAX_FUSION = 11,
   NODE_TYPE_ASSERT = 13,
   NODE_TYPE_AVG_POOL_FUSION = 17,
+  NODE_TYPE_BATCH_TO_SPACE = 21,
   NODE_TYPE_BATCH_TO_SPACE_ND = 22,
   NODE_TYPE_BIAS_ADD = 23,
   NODE_TYPE_BROADCAST_TO = 27,
@@ -96,15 +97,25 @@ enum NodeType : uint32_t {
   NODE_TYPE_COS = 37,
   NODE_TYPE_CONSTANT_OF_SHAPE = 38,
   NODE_TYPE_CROP = 39,
+  NODE_TYPE_DEPEND = 44,
   NODE_TYPE_DEPTH_TO_SPACE = 45,
   NODE_TYPE_DETECTION_POST_PROCESS = 46,
   NODE_TYPE_DIV_FUSION = 47,
+  NODE_TYPE_DROPOUT = 49,
+  NODE_TYPE_ELU = 51,
   NODE_TYPE_ELTWISE = 52,
   NODE_TYPE_EQUAL = 53,
+  NODE_TYPE_EMBEDDING_LOOKUP_FUSION = 54,
   NODE_TYPE_EXPFUSION = 55,
   NODE_TYPE_EXPAND_DIMS = 56,
+  NODE_TYPE_FAKE_QUANT_WITH_MIN_MAX_VARS = 57,
+  NODE_TYPE_FAKE_QUANT_WITH_MIN_MAX_VARS_PER_CHANNEL = 58,
+  NODE_TYPE_FFT_REAL = 59,
+  NODE_TYPE_FFT_IMAG = 60,
   NODE_TYPE_FLATTEN = 61,
   NODE_TYPE_FLOOR = 63,
+  NODE_TYPE_FLOOR_DIV = 64,
+  NODE_TYPE_FLOOR_MOD = 65,
   NODE_TYPE_FILL = 66,
   NODE_TYPE_FULL_CONNECTION = 67,
   NODE_TYPE_FUSED_BATCH_NORM = 68,
@@ -112,6 +123,7 @@ enum NodeType : uint32_t {
   NODE_TYPE_GATHER_ND = 70,
   NODE_TYPE_GREATER = 71,
   NODE_TYPE_GREATER_EQUAL = 72,
+  NODE_TYPE_HASHTABLE_LOOKUP = 73,
   NODE_TYPE_INSTANCE_NORM = 74,
   NODE_TYPE_LAYER_NORM_FUSION = 75,
   NODE_TYPE_LEAKY_RELU = 76,
@@ -121,20 +133,28 @@ enum NodeType : uint32_t {
   NODE_TYPE_LOGICAL_AND = 81,
   NODE_TYPE_LOGICAL_NOT = 82,
   NODE_TYPE_LOGICAL_OR = 83,
+  NODE_TYPE_LP_NORMALIZATION = 84,
   NODE_TYPE_L_R_N = 85,
+  NODE_TYPE_LSH_PROJECTION = 86,
   NODE_TYPE_LSTM = 87,
   NODE_TYPE_L2_NORMALIZE_FUSION = 88,
   NODE_TYPE_MATMUL_FUSION = 89,
   NODE_TYPE_MAXIMUM = 90,
   NODE_TYPE_MAX_POOL_FUSION = 92,
+  NODE_TYPE_SWITCH_LAYER = 94,
+  NODE_TYPE_MFCC = 95,
   NODE_TYPE_MINIMUM = 96,
   NODE_TYPE_MOD = 98,
   NODE_TYPE_MUL_FUSION = 99,
   NODE_TYPE_NEG = 101,
   NODE_TYPE_NOT_EQUAL = 103,
+  NODE_TYPE_NON_MAX_SUPPRESSION = 104,
   NODE_TYPE_ONE_HOT = 105,
+  NODE_TYPE_ONES_LIKE = 106,
   NODE_TYPE_PAD_FUSION = 107,
+  NODE_TYPE_PARTIAL_FUSION = 108,
   NODE_TYPE_POW_FUSION = 110,
+  NODE_TYPE_PRIOR_BOX = 111,
   NODE_TYPE_PRELU_FUSION = 112,
   NODE_TYPE_QUANT_DTYPE_CAST = 113,
   NODE_TYPE_RANK = 114,
@@ -144,12 +164,17 @@ enum NodeType : uint32_t {
   NODE_TYPE_REDUCE_FUSION = 118,
   NODE_TYPE_RESHAPE = 119,
   NODE_TYPE_RESIZE = 120,
+  NODE_TYPE_REVERSE_SEQUENCE = 121,
+  NODE_TYPE_REVERSE_V2 = 122,
+  NODE_TYPE_RFFT = 123,
+  NODE_TYPE_R_O_I_POOLING = 124,
   NODE_TYPE_ROUND = 125,
   NODE_TYPE_RSQRT = 126,
   NODE_TYPE_SCALE_FUSION = 127,
   NODE_TYPE_SCATTER_ND = 128,
   NODE_TYPE_SHAPE = 130,
   NODE_TYPE_SIN = 133,
+  NODE_TYPE_SKIP_GRAM = 134,
   NODE_TYPE_SLICE_FUSION = 135,
   NODE_TYPE_SOFTMAX = 138,
   NODE_TYPE_SPACE_TO_BATCH_ND = 141,
@@ -163,16 +188,51 @@ enum NodeType : uint32_t {
   NODE_TYPE_STACK = 150,
   NODE_TYPE_STRIDED_SLICE = 151,
   NODE_TYPE_SUB_FUSION = 152,
+  NODE_TYPE_SWITCH = 154,
   NODE_TYPE_TILE_FUSION = 160,
   NODE_TYPE_TOPK_FUSION = 161,
   NODE_TYPE_TRANSPOSE = 162,
+  NODE_TYPE_UNIQUE = 163,
+  NODE_TYPE_UNSORTED_SEGMENT_SUM = 164,
   NODE_TYPE_UNSQUEEZE = 165,
   NODE_TYPE_UNSTACK = 166,
   NODE_TYPE_WHERE = 168,
+  NODE_TYPE_ZEROS_LIKE = 169,
   NODE_TYPE_SELECT = 170,
+  NODE_TYPE_G_R_U = 172,
+  NODE_TYPE_NON_ZERO = 173,
+  NODE_TYPE_INVERT_PERMUTATION = 174,
+  NODE_TYPE_SIZE = 175,
+  NODE_TYPE_RANDOM_STANDARD_NORMAL = 176,
+  NODE_TYPE_CROP_AND_RESIZE = 177,
   NODE_TYPE_ERF = 178,
+  NODE_TYPE_IS_FINITE = 180,
+  NODE_TYPE_LIN_SPACE = 181,
+  NODE_TYPE_UNIFORM_REAL = 182,
+  NODE_TYPE_SPLICE = 188,
   NODE_TYPE_LOG_SOFTMAX = 189,
+  NODE_TYPE_CALL = 190,
   NODE_TYPE_CUSTOM = 191,
+  NODE_TYPE_CUM_SUM = 192,
+  NODE_TYPE_SPLIT_WITH_OVERLAP = 193,
+  NODE_TYPE_GEN_O_P = 194,
+  NODE_TYPE_RAGGED_RANGE = 195,
+  NODE_TYPE_G_L_U = 196,
+  NODE_TYPE_AFFINE = 200,
+  NODE_TYPE_ALL_GATHER = 201,
+  NODE_TYPE_REDUCE_SCATTER = 202,
+  NODE_TYPE_DYNAMIC_QUANT = 203,
+  NODE_TYPE_RANDOM_NORMAL = 206,
+  NODE_TYPE_FORMAT_TRANSPOSE = 209,
+  NODE_TYPE_GATHER_D = 210,
+  NODE_TYPE_GROUP_NORM_FUSION = 211,
+  NODE_TYPE_LOG1P = 212,
+  NODE_TYPE_SPARSE_FILL_EMPTY_ROWS = 214,
+  NODE_TYPE_SPARSE_RESHAPE = 215,
+  NODE_TYPE_SPARSE_SEGMENT_SUM = 216,
+  NODE_TYPE_SCATTER_ELEMENTS = 217,
+  NODE_TYPE_TRIU = 218,
+  NODE_TYPE_TRIL = 219,
 };
 
 enum ResizeMethod : int8_t {
diff --git a/mindspore/lite/mindir/src/mindir.cc b/mindspore/lite/mindir/src/mindir.cc
index a1f86671..39600e4d 100644
--- a/mindspore/lite/mindir/src/mindir.cc
+++ b/mindspore/lite/mindir/src/mindir.cc
@@ -4674,10 +4674,10 @@ std::string MindIR_DepthToSpace_GetMode(ConstPrimitivePtr primitive) {
     if (prim != nullptr && value != nullptr) {
       return std::string(value->mode()->c_str(),value->mode()->size());
     } else {
-      return nullptr;
+      return "";
     }
   } else {
-    return nullptr;
+    return "";
   }
 }
 
@@ -6210,10 +6210,10 @@ std::string MindIR_LRN_GetNormRegion(ConstPrimitivePtr primitive) {
     if (prim != nullptr && value != nullptr) {
       return std::string(value->norm_region()->c_str(),value->norm_region()->size());
     } else {
-      return nullptr;
+      return "";
     }
   } else {
-    return nullptr;
+    return "";
   }
 }
 
@@ -6750,6 +6750,104 @@ PrimitivePtr MindIR_GatherNd_CreatePrimitive() {
   return ret_value;
 }
 
+// ********** BatchToSpace **********
+PrimitivePtr MindIR_BatchToSpace_CreatePrimitive(const std::vector<int64_t> &block_size,
+                                                 const std::vector<std::vector<int64_t>> &crops) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateBatchToSpace(fbb, fbb.CreateVector(block_size.data(), block_size.size()),
+                                               CreateVec2D(fbb, crops));
+  auto prim_offset =
+    schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_BATCH_TO_SPACE), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+std::vector<int64_t> MindIR_BatchToSpace_GetBlockSize(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_BatchToSpace();
+    if (prim != nullptr && value != nullptr) {
+      std::vector<int64_t> result;
+      auto src = value->block_size();
+      if (src == nullptr) {
+        return {};
+      }
+      result.resize(src->size());
+      std::transform(src->begin(), src->end(), result.begin(), [](int64_t item) { return item; });
+      return result;
+    } else {
+      return {};
+    }
+  } else {
+    return {};
+  }
+}
+
+void MindIR_BatchToSpace_SetBlockSize(PrimitivePtr *primitive, const std::vector<int64_t> &block_size) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_BatchToSpace();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateBatchToSpace(fbb, fbb.CreateVector(block_size.data(), block_size.size()),
+                                                   CreateVec2D(fbb, value->crops()));
+      auto prim_offset =
+        schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_BATCH_TO_SPACE), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+std::vector<std::vector<int64_t>> MindIR_BatchToSpace_GetCrops(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_BatchToSpace();
+    if (prim != nullptr && value != nullptr) {
+      std::vector<std::vector<int64_t>> out;
+      auto src = value->crops();
+      if (src == nullptr) {
+        return {};
+      }
+      for (auto sub_list : *src->data()) {
+        std::vector<int64_t> result_tmp;
+        result_tmp.resize(sub_list->data()->size());
+        std::transform(sub_list->data()->begin(), sub_list->data()->end(), result_tmp.begin(),
+                       [](int64_t item) { return item; });
+        out.emplace_back(result_tmp);
+      }
+      return out;
+    } else {
+      return {};
+    }
+  } else {
+    return {};
+  }
+}
+
+void MindIR_BatchToSpace_SetCrops(PrimitivePtr *primitive, const std::vector<std::vector<int64_t>> &crops) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_BatchToSpace();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateBatchToSpace(
+        fbb, fbb.CreateVector(value->block_size()->data(), value->block_size()->size()), CreateVec2D(fbb, crops));
+      auto prim_offset =
+        schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_BATCH_TO_SPACE), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, prim);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      *primitive = ret_value;
+    }
+  }
+}
+
 // ********** Custom **********
 std::vector<const mindspore::schema::Attribute *> MindIR_Custom_GetAttr(ConstPrimitivePtr primitive) {
   if (primitive == nullptr) {
diff --git a/mindspore/lite/mindir/src/mindir_1.cc b/mindspore/lite/mindir/src/mindir_1.cc
new file mode 100644
index 00000000..5177e881
--- /dev/null
+++ b/mindspore/lite/mindir/src/mindir_1.cc
@@ -0,0 +1,2061 @@
+/**
+ * Copyright 2024 Huawei Technologies Co., Ltd
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "mindir.h"
+#include "utils.h"
+#include "schema/model_generated.h"
+#include "mindir_memory_manager.h"
+
+namespace mindspore {
+namespace lite {
+// ********** Depend **********
+PrimitivePtr MindIR_Depend_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateDepend(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_DEPEND), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** Dropout **********
+PrimitivePtr MindIR_Dropout_CreatePrimitive(float keep_prob) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateDropout(fbb, keep_prob);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_DROPOUT), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+float MindIR_Dropout_GetKeepProb(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_Dropout();
+    if (prim != nullptr && value != nullptr) {
+      return value->keep_prob();
+    } else {
+      return .0;
+    }
+  } else {
+    return .0;
+  }
+}
+
+void MindIR_Dropout_SetKeepProb(PrimitivePtr *primitive, float keep_prob) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_Dropout();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateDropout(fbb, keep_prob);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_DROPOUT), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, prim);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** Elu **********
+PrimitivePtr MindIR_Elu_CreatePrimitive(float alpha) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateElu(fbb, alpha);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_ELU), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+float MindIR_Elu_GetAlpha(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_Elu();
+    if (prim != nullptr && value != nullptr) {
+      return value->alpha();
+    } else {
+      return .0;
+    }
+  } else {
+    return .0;
+  }
+}
+
+void MindIR_Elu_SetAlpha(PrimitivePtr *primitive, float alpha) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_Elu();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateElu(fbb, alpha);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_ELU), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, prim);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** EmbeddingLookupFusion **********
+PrimitivePtr MindIR_EmbeddingLookupFusion_CreatePrimitive(float max_norm) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateEmbeddingLookupFusion(fbb, max_norm);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_EMBEDDING_LOOKUP_FUSION), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+float MindIR_EmbeddingLookupFusion_GetMaxNorm(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_EmbeddingLookupFusion();
+    if (prim != nullptr && value != nullptr) {
+      return value->max_norm();
+    } else {
+      return .0;
+    }
+  } else {
+    return .0;
+  }
+}
+
+void MindIR_EmbeddingLookupFusion_SetMaxNorm(PrimitivePtr *primitive, float max_norm) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_EmbeddingLookupFusion();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateEmbeddingLookupFusion(fbb, max_norm);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_EMBEDDING_LOOKUP_FUSION), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, prim);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** FakeQuantWithMinMaxVars **********
+PrimitivePtr MindIR_FakeQuantWithMinMaxVars_CreatePrimitive(int64_t num_bits, bool narrow_range) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateFakeQuantWithMinMaxVars(fbb, num_bits, narrow_range);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_FAKE_QUANT_WITH_MIN_MAX_VARS), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+int64_t MindIR_FakeQuantWithMinMaxVars_GetNumBits(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_FakeQuantWithMinMaxVars();
+    if (prim != nullptr && value != nullptr) {
+      return value->num_bits();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_FakeQuantWithMinMaxVars_SetNumBits(PrimitivePtr *primitive, int64_t num_bits) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_FakeQuantWithMinMaxVars();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateFakeQuantWithMinMaxVars(fbb, num_bits, value->narrow_range());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_FAKE_QUANT_WITH_MIN_MAX_VARS), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+bool MindIR_FakeQuantWithMinMaxVars_GetNarrowRange(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_FakeQuantWithMinMaxVars();
+    if (prim != nullptr && value != nullptr) {
+      return value->narrow_range();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_FakeQuantWithMinMaxVars_SetNarrowRange(PrimitivePtr *primitive, bool narrow_range) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_FakeQuantWithMinMaxVars();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateFakeQuantWithMinMaxVars(fbb, value->num_bits(), narrow_range);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_FAKE_QUANT_WITH_MIN_MAX_VARS), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** FakeQuantWithMinMaxVarsPerChannel **********
+PrimitivePtr MindIR_FakeQuantWithMinMaxVarsPerChannel_CreatePrimitive(int64_t num_bits, bool narrow_range) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateFakeQuantWithMinMaxVarsPerChannel(fbb, num_bits, narrow_range);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_FAKE_QUANT_WITH_MIN_MAX_VARS_PER_CHANNEL), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+int64_t MindIR_FakeQuantWithMinMaxVarsPerChannel_GetNumBits(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_FakeQuantWithMinMaxVarsPerChannel();
+    if (prim != nullptr && value != nullptr) {
+      return value->num_bits();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_FakeQuantWithMinMaxVarsPerChannel_SetNumBits(PrimitivePtr *primitive, int64_t num_bits) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_FakeQuantWithMinMaxVarsPerChannel();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateFakeQuantWithMinMaxVarsPerChannel(fbb, num_bits, value->narrow_range());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_FAKE_QUANT_WITH_MIN_MAX_VARS_PER_CHANNEL), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+bool MindIR_FakeQuantWithMinMaxVarsPerChannel_GetNarrowRange(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_FakeQuantWithMinMaxVarsPerChannel();
+    if (prim != nullptr && value != nullptr) {
+      return value->narrow_range();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_FakeQuantWithMinMaxVarsPerChannel_SetNarrowRange(PrimitivePtr *primitive, bool narrow_range) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_FakeQuantWithMinMaxVarsPerChannel();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateFakeQuantWithMinMaxVarsPerChannel(fbb, value->num_bits(), narrow_range);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_FAKE_QUANT_WITH_MIN_MAX_VARS_PER_CHANNEL), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** FftReal **********
+PrimitivePtr MindIR_FftReal_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateFftReal(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_FFT_REAL), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** FftImag **********
+PrimitivePtr MindIR_FftImag_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateFftImag(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_FFT_IMAG), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** FloorDiv **********
+PrimitivePtr MindIR_FloorDiv_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateFloorDiv(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_FLOOR_DIV), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** FloorMod **********
+PrimitivePtr MindIR_FloorMod_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateFloorMod(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_FLOOR_MOD), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** HashtableLookup **********
+PrimitivePtr MindIR_HashtableLookup_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateHashtableLookup(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_HASHTABLE_LOOKUP), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** LpNormalization **********
+PrimitivePtr MindIR_LpNormalization_CreatePrimitive(int64_t axis, int64_t p) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateLpNormalization(fbb, axis, p);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_LP_NORMALIZATION), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+int64_t MindIR_LpNormalization_GetAxis(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_LpNormalization();
+    if (prim != nullptr && value != nullptr) {
+      return value->axis();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_LpNormalization_SetAxis(PrimitivePtr *primitive, int64_t axis) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_LpNormalization();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateLpNormalization(fbb, axis, value->p());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_LP_NORMALIZATION), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, prim);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      *primitive = ret_value;
+    }
+  }
+}
+
+int64_t MindIR_LpNormalization_GetP(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_LpNormalization();
+    if (prim != nullptr && value != nullptr) {
+      return value->p();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_LpNormalization_SetP(PrimitivePtr *primitive, int64_t p) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_LpNormalization();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateLpNormalization(fbb, value->axis(), p);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_LP_NORMALIZATION), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, prim);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** LshProjection **********
+PrimitivePtr MindIR_LshProjection_CreatePrimitive(LshProjectionType type) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateLshProjection(fbb, static_cast<schema::LshProjectionType>(type));
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_LSH_PROJECTION), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+LshProjectionType MindIR_LshProjection_GetType(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_LshProjection();
+    if (prim != nullptr && value != nullptr) {
+      return static_cast<LshProjectionType>(value->type());
+    } else {
+      LshProjectionType en = static_cast<LshProjectionType>(0);
+      return en;
+    }
+  } else {
+    LshProjectionType en = static_cast<LshProjectionType>(0);
+    return en;
+  }
+}
+
+void MindIR_LshProjection_SetType(PrimitivePtr *primitive, LshProjectionType type) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_LshProjection();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateLshProjection(fbb, static_cast<schema::LshProjectionType>(type));
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_LSH_PROJECTION), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** SwitchLayer **********
+PrimitivePtr MindIR_SwitchLayer_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateSwitchLayer(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SWITCH_LAYER), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** Mfcc **********
+PrimitivePtr MindIR_Mfcc_CreatePrimitive(float freq_upper_limit, float freq_lower_limit, int64_t filter_bank_channel_num, int64_t dct_coeff_num) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateMfcc(fbb, freq_upper_limit, freq_lower_limit, filter_bank_channel_num, dct_coeff_num);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_MFCC), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+float MindIR_Mfcc_GetFreqUpperLimit(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_Mfcc();
+    if (prim != nullptr && value != nullptr) {
+      return value->freq_upper_limit();
+    } else {
+      return .0;
+    }
+  } else {
+    return .0;
+  }
+}
+
+void MindIR_Mfcc_SetFreqUpperLimit(PrimitivePtr *primitive, float freq_upper_limit) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_Mfcc();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateMfcc(fbb, freq_upper_limit, value->freq_lower_limit(), value->filter_bank_channel_num(), value->dct_coeff_num());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_MFCC), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+float MindIR_Mfcc_GetFreqLowerLimit(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_Mfcc();
+    if (prim != nullptr && value != nullptr) {
+      return value->freq_lower_limit();
+    } else {
+      return .0;
+    }
+  } else {
+    return .0;
+  }
+}
+
+void MindIR_Mfcc_SetFreqLowerLimit(PrimitivePtr *primitive, float freq_lower_limit) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_Mfcc();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateMfcc(fbb, value->freq_upper_limit(), freq_lower_limit, value->filter_bank_channel_num(), value->dct_coeff_num());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_MFCC), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+int64_t MindIR_Mfcc_GetFilterBankChannelNum(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_Mfcc();
+    if (prim != nullptr && value != nullptr) {
+      return value->filter_bank_channel_num();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_Mfcc_SetFilterBankChannelNum(PrimitivePtr *primitive, int64_t filter_bank_channel_num) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_Mfcc();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateMfcc(fbb, value->freq_upper_limit(), value->freq_lower_limit(), filter_bank_channel_num, value->dct_coeff_num());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_MFCC), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+int64_t MindIR_Mfcc_GetDctCoeffNum(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_Mfcc();
+    if (prim != nullptr && value != nullptr) {
+      return value->dct_coeff_num();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_Mfcc_SetDctCoeffNum(PrimitivePtr *primitive, int64_t dct_coeff_num) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_Mfcc();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateMfcc(fbb, value->freq_upper_limit(), value->freq_lower_limit(), value->filter_bank_channel_num(), dct_coeff_num);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_MFCC), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** NonMaxSuppression **********
+PrimitivePtr MindIR_NonMaxSuppression_CreatePrimitive(int64_t center_point_box) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateNonMaxSuppression(fbb, center_point_box);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_NON_MAX_SUPPRESSION), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+int64_t MindIR_NonMaxSuppression_GetCenterPointBox(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_NonMaxSuppression();
+    if (prim != nullptr && value != nullptr) {
+      return value->center_point_box();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_NonMaxSuppression_SetCenterPointBox(PrimitivePtr *primitive, int64_t center_point_box) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_NonMaxSuppression();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateNonMaxSuppression(fbb, center_point_box);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_NON_MAX_SUPPRESSION), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** OnesLike **********
+PrimitivePtr MindIR_OnesLike_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateOnesLike(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_ONES_LIKE), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** PartialFusion **********
+PrimitivePtr MindIR_PartialFusion_CreatePrimitive(int64_t sub_graph_index) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreatePartialFusion(fbb, sub_graph_index);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_PARTIAL_FUSION), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+int64_t MindIR_PartialFusion_GetSubGraphIndex(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_PartialFusion();
+    if (prim != nullptr && value != nullptr) {
+      return value->sub_graph_index();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_PartialFusion_SetSubGraphIndex(PrimitivePtr *primitive, int64_t sub_graph_index) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_PartialFusion();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreatePartialFusion(fbb, sub_graph_index);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_PARTIAL_FUSION), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** PriorBox **********
+PrimitivePtr MindIR_PriorBox_CreatePrimitive(const std::vector<int64_t> &min_sizes, const std::vector<int64_t> &max_sizes, const std::vector<float> &aspect_ratios, const std::vector<float> &variances, int64_t image_size_w, int64_t image_size_h, float step_w, float step_h, bool clip, bool flip, float offset) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreatePriorBox(fbb, fbb.CreateVector(min_sizes.data(), min_sizes.size()), fbb.CreateVector(max_sizes.data(), max_sizes.size()), fbb.CreateVector(aspect_ratios.data(), aspect_ratios.size()), fbb.CreateVector(variances.data(), variances.size()), image_size_w, image_size_h, step_w, step_h, clip, flip, offset);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_PRIOR_BOX), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+std::vector<int64_t> MindIR_PriorBox_GetMinSizes(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      std::vector<int64_t> result;
+      auto src = value->min_sizes();
+      if (src == nullptr) {
+        return {};
+      }
+      result.resize(src->size());
+      std::transform(src->begin(), src->end(), result.begin(), [](int64_t item) { return item; });
+      return result;
+    } else {
+      return {};
+    }
+  } else {
+    return {};
+  }
+}
+
+void MindIR_PriorBox_SetMinSizes(PrimitivePtr *primitive, const std::vector<int64_t> &min_sizes) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreatePriorBox(fbb, fbb.CreateVector(min_sizes.data(), min_sizes.size()), fbb.CreateVector(value->max_sizes()->data(), value->max_sizes()->size()), fbb.CreateVector(value->aspect_ratios()->data(), value->aspect_ratios()->size()), fbb.CreateVector(value->variances()->data(), value->variances()->size()), value->image_size_w(), value->image_size_h(), value->step_w(), value->step_h(), value->clip(), value->flip(), value->offset());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_PRIOR_BOX), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+std::vector<int64_t> MindIR_PriorBox_GetMaxSizes(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      std::vector<int64_t> result;
+      auto src = value->max_sizes();
+      if (src == nullptr) {
+        return {};
+      }
+      result.resize(src->size());
+      std::transform(src->begin(), src->end(), result.begin(), [](int64_t item) { return item; });
+      return result;
+    } else {
+      return {};
+    }
+  } else {
+    return {};
+  }
+}
+
+void MindIR_PriorBox_SetMaxSizes(PrimitivePtr *primitive, const std::vector<int64_t> &max_sizes) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreatePriorBox(fbb, fbb.CreateVector(value->min_sizes()->data(), value->min_sizes()->size()), fbb.CreateVector(max_sizes.data(), max_sizes.size()), fbb.CreateVector(value->aspect_ratios()->data(), value->aspect_ratios()->size()), fbb.CreateVector(value->variances()->data(), value->variances()->size()), value->image_size_w(), value->image_size_h(), value->step_w(), value->step_h(), value->clip(), value->flip(), value->offset());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_PRIOR_BOX), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+std::vector<float> MindIR_PriorBox_GetAspectRatios(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      std::vector<float> result;
+      auto src = value->aspect_ratios();
+      if (src == nullptr) {
+        return {};
+      }
+      result.resize(src->size());
+      std::transform(src->begin(), src->end(), result.begin(), [](float item) { return item; });
+      return result;
+    } else {
+      return {};
+    }
+  } else {
+    return {};
+  }
+}
+
+void MindIR_PriorBox_SetAspectRatios(PrimitivePtr *primitive, const std::vector<float> &aspect_ratios) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreatePriorBox(fbb, fbb.CreateVector(value->min_sizes()->data(), value->min_sizes()->size()), fbb.CreateVector(value->max_sizes()->data(), value->max_sizes()->size()), fbb.CreateVector(aspect_ratios.data(), aspect_ratios.size()), fbb.CreateVector(value->variances()->data(), value->variances()->size()), value->image_size_w(), value->image_size_h(), value->step_w(), value->step_h(), value->clip(), value->flip(), value->offset());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_PRIOR_BOX), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+std::vector<float> MindIR_PriorBox_GetVariances(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      std::vector<float> result;
+      auto src = value->variances();
+      if (src == nullptr) {
+        return {};
+      }
+      result.resize(src->size());
+      std::transform(src->begin(), src->end(), result.begin(), [](float item) { return item; });
+      return result;
+    } else {
+      return {};
+    }
+  } else {
+    return {};
+  }
+}
+
+void MindIR_PriorBox_SetVariances(PrimitivePtr *primitive, const std::vector<float> &variances) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreatePriorBox(fbb, fbb.CreateVector(value->min_sizes()->data(), value->min_sizes()->size()), fbb.CreateVector(value->max_sizes()->data(), value->max_sizes()->size()), fbb.CreateVector(value->aspect_ratios()->data(), value->aspect_ratios()->size()), fbb.CreateVector(variances.data(), variances.size()), value->image_size_w(), value->image_size_h(), value->step_w(), value->step_h(), value->clip(), value->flip(), value->offset());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_PRIOR_BOX), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+int64_t MindIR_PriorBox_GetImageSizeW(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      return value->image_size_w();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_PriorBox_SetImageSizeW(PrimitivePtr *primitive, int64_t image_size_w) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreatePriorBox(fbb, fbb.CreateVector(value->min_sizes()->data(), value->min_sizes()->size()), fbb.CreateVector(value->max_sizes()->data(), value->max_sizes()->size()), fbb.CreateVector(value->aspect_ratios()->data(), value->aspect_ratios()->size()), fbb.CreateVector(value->variances()->data(), value->variances()->size()), image_size_w, value->image_size_h(), value->step_w(), value->step_h(), value->clip(), value->flip(), value->offset());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_PRIOR_BOX), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+int64_t MindIR_PriorBox_GetImageSizeH(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      return value->image_size_h();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_PriorBox_SetImageSizeH(PrimitivePtr *primitive, int64_t image_size_h) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreatePriorBox(fbb, fbb.CreateVector(value->min_sizes()->data(), value->min_sizes()->size()), fbb.CreateVector(value->max_sizes()->data(), value->max_sizes()->size()), fbb.CreateVector(value->aspect_ratios()->data(), value->aspect_ratios()->size()), fbb.CreateVector(value->variances()->data(), value->variances()->size()), value->image_size_w(), image_size_h, value->step_w(), value->step_h(), value->clip(), value->flip(), value->offset());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_PRIOR_BOX), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+float MindIR_PriorBox_GetStepW(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      return value->step_w();
+    } else {
+      return .0;
+    }
+  } else {
+    return .0;
+  }
+}
+
+void MindIR_PriorBox_SetStepW(PrimitivePtr *primitive, float step_w) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreatePriorBox(fbb, fbb.CreateVector(value->min_sizes()->data(), value->min_sizes()->size()), fbb.CreateVector(value->max_sizes()->data(), value->max_sizes()->size()), fbb.CreateVector(value->aspect_ratios()->data(), value->aspect_ratios()->size()), fbb.CreateVector(value->variances()->data(), value->variances()->size()), value->image_size_w(), value->image_size_h(), step_w, value->step_h(), value->clip(), value->flip(), value->offset());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_PRIOR_BOX), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+float MindIR_PriorBox_GetStepH(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      return value->step_h();
+    } else {
+      return .0;
+    }
+  } else {
+    return .0;
+  }
+}
+
+void MindIR_PriorBox_SetStepH(PrimitivePtr *primitive, float step_h) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreatePriorBox(fbb, fbb.CreateVector(value->min_sizes()->data(), value->min_sizes()->size()), fbb.CreateVector(value->max_sizes()->data(), value->max_sizes()->size()), fbb.CreateVector(value->aspect_ratios()->data(), value->aspect_ratios()->size()), fbb.CreateVector(value->variances()->data(), value->variances()->size()), value->image_size_w(), value->image_size_h(), value->step_w(), step_h, value->clip(), value->flip(), value->offset());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_PRIOR_BOX), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+bool MindIR_PriorBox_GetClip(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      return value->clip();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_PriorBox_SetClip(PrimitivePtr *primitive, bool clip) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreatePriorBox(fbb, fbb.CreateVector(value->min_sizes()->data(), value->min_sizes()->size()), fbb.CreateVector(value->max_sizes()->data(), value->max_sizes()->size()), fbb.CreateVector(value->aspect_ratios()->data(), value->aspect_ratios()->size()), fbb.CreateVector(value->variances()->data(), value->variances()->size()), value->image_size_w(), value->image_size_h(), value->step_w(), value->step_h(), clip, value->flip(), value->offset());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_PRIOR_BOX), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+bool MindIR_PriorBox_GetFlip(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      return value->flip();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_PriorBox_SetFlip(PrimitivePtr *primitive, bool flip) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreatePriorBox(fbb, fbb.CreateVector(value->min_sizes()->data(), value->min_sizes()->size()), fbb.CreateVector(value->max_sizes()->data(), value->max_sizes()->size()), fbb.CreateVector(value->aspect_ratios()->data(), value->aspect_ratios()->size()), fbb.CreateVector(value->variances()->data(), value->variances()->size()), value->image_size_w(), value->image_size_h(), value->step_w(), value->step_h(), value->clip(), flip, value->offset());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_PRIOR_BOX), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+float MindIR_PriorBox_GetOffset(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      return value->offset();
+    } else {
+      return .0;
+    }
+  } else {
+    return .0;
+  }
+}
+
+void MindIR_PriorBox_SetOffset(PrimitivePtr *primitive, float offset) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_PriorBox();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreatePriorBox(fbb, fbb.CreateVector(value->min_sizes()->data(), value->min_sizes()->size()), fbb.CreateVector(value->max_sizes()->data(), value->max_sizes()->size()), fbb.CreateVector(value->aspect_ratios()->data(), value->aspect_ratios()->size()), fbb.CreateVector(value->variances()->data(), value->variances()->size()), value->image_size_w(), value->image_size_h(), value->step_w(), value->step_h(), value->clip(), value->flip(), offset);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_PRIOR_BOX), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** ReverseSequence **********
+PrimitivePtr MindIR_ReverseSequence_CreatePrimitive(int64_t seq_dim, int64_t batch_dim) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateReverseSequence(fbb, seq_dim, batch_dim);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_REVERSE_SEQUENCE), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+int64_t MindIR_ReverseSequence_GetSeqDim(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_ReverseSequence();
+    if (prim != nullptr && value != nullptr) {
+      return value->seq_dim();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_ReverseSequence_SetSeqDim(PrimitivePtr *primitive, int64_t seq_dim) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_ReverseSequence();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateReverseSequence(fbb, seq_dim, value->batch_dim());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_REVERSE_SEQUENCE), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+int64_t MindIR_ReverseSequence_GetBatchDim(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_ReverseSequence();
+    if (prim != nullptr && value != nullptr) {
+      return value->batch_dim();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_ReverseSequence_SetBatchDim(PrimitivePtr *primitive, int64_t batch_dim) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_ReverseSequence();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateReverseSequence(fbb, value->seq_dim(), batch_dim);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_REVERSE_SEQUENCE), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** ReverseV2 **********
+PrimitivePtr MindIR_ReverseV2_CreatePrimitive(const std::vector<int64_t> &axis) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateReverseV2(fbb, fbb.CreateVector(axis.data(), axis.size()));
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_REVERSE_V2), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+std::vector<int64_t> MindIR_ReverseV2_GetAxis(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_ReverseV2();
+    if (prim != nullptr && value != nullptr) {
+      std::vector<int64_t> result;
+      auto src = value->axis();
+      if (src == nullptr) {
+        return {};
+      }
+      result.resize(src->size());
+      std::transform(src->begin(), src->end(), result.begin(), [](int64_t item) { return item; });
+      return result;
+    } else {
+      return {};
+    }
+  } else {
+    return {};
+  }
+}
+
+void MindIR_ReverseV2_SetAxis(PrimitivePtr *primitive, const std::vector<int64_t> &axis) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_ReverseV2();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateReverseV2(fbb, fbb.CreateVector(axis.data(), axis.size()));
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_REVERSE_V2), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** Rfft **********
+PrimitivePtr MindIR_Rfft_CreatePrimitive(int64_t fft_length) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateRfft(fbb, fft_length);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_RFFT), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+int64_t MindIR_Rfft_GetFftLength(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_Rfft();
+    if (prim != nullptr && value != nullptr) {
+      return value->fft_length();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_Rfft_SetFftLength(PrimitivePtr *primitive, int64_t fft_length) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_Rfft();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateRfft(fbb, fft_length);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_RFFT), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** ROIPooling **********
+PrimitivePtr MindIR_ROIPooling_CreatePrimitive(int64_t pooled_h, int64_t pooled_w, float scale) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateROIPooling(fbb, pooled_h, pooled_w, scale);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_R_O_I_POOLING), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+int64_t MindIR_ROIPooling_GetPooledH(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_ROIPooling();
+    if (prim != nullptr && value != nullptr) {
+      return value->pooled_h();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_ROIPooling_SetPooledH(PrimitivePtr *primitive, int64_t pooled_h) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_ROIPooling();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateROIPooling(fbb, pooled_h, value->pooled_w(), value->scale());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_R_O_I_POOLING), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+int64_t MindIR_ROIPooling_GetPooledW(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_ROIPooling();
+    if (prim != nullptr && value != nullptr) {
+      return value->pooled_w();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_ROIPooling_SetPooledW(PrimitivePtr *primitive, int64_t pooled_w) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_ROIPooling();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateROIPooling(fbb, value->pooled_h(), pooled_w, value->scale());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_R_O_I_POOLING), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+float MindIR_ROIPooling_GetScale(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_ROIPooling();
+    if (prim != nullptr && value != nullptr) {
+      return value->scale();
+    } else {
+      return .0;
+    }
+  } else {
+    return .0;
+  }
+}
+
+void MindIR_ROIPooling_SetScale(PrimitivePtr *primitive, float scale) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_ROIPooling();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateROIPooling(fbb, value->pooled_h(), value->pooled_w(), scale);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_R_O_I_POOLING), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** SkipGram **********
+PrimitivePtr MindIR_SkipGram_CreatePrimitive(bool include_all_grams, int64_t max_skip_size, int64_t ngram_size) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateSkipGram(fbb, include_all_grams, max_skip_size, ngram_size);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SKIP_GRAM), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+bool MindIR_SkipGram_GetIncludeAllGrams(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_SkipGram();
+    if (prim != nullptr && value != nullptr) {
+      return value->include_all_grams();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_SkipGram_SetIncludeAllGrams(PrimitivePtr *primitive, bool include_all_grams) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_SkipGram();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateSkipGram(fbb, include_all_grams, value->max_skip_size(), value->ngram_size());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SKIP_GRAM), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+int64_t MindIR_SkipGram_GetMaxSkipSize(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_SkipGram();
+    if (prim != nullptr && value != nullptr) {
+      return value->max_skip_size();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_SkipGram_SetMaxSkipSize(PrimitivePtr *primitive, int64_t max_skip_size) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_SkipGram();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateSkipGram(fbb, value->include_all_grams(), max_skip_size, value->ngram_size());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SKIP_GRAM), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+int64_t MindIR_SkipGram_GetNgramSize(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_SkipGram();
+    if (prim != nullptr && value != nullptr) {
+      return value->ngram_size();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_SkipGram_SetNgramSize(PrimitivePtr *primitive, int64_t ngram_size) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_SkipGram();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateSkipGram(fbb, value->include_all_grams(), value->max_skip_size(), ngram_size);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SKIP_GRAM), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** Switch **********
+PrimitivePtr MindIR_Switch_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateSwitch(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SWITCH), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** Unique **********
+PrimitivePtr MindIR_Unique_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateUnique(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_UNIQUE), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** UnsortedSegmentSum **********
+PrimitivePtr MindIR_UnsortedSegmentSum_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateUnsortedSegmentSum(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_UNSORTED_SEGMENT_SUM), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** ZerosLike **********
+PrimitivePtr MindIR_ZerosLike_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateZerosLike(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_ZEROS_LIKE), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** GRU **********
+PrimitivePtr MindIR_GRU_CreatePrimitive(bool bidirectional) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateGRU(fbb, bidirectional);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_G_R_U), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+bool MindIR_GRU_GetBidirectional(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GRU();
+    if (prim != nullptr && value != nullptr) {
+      return value->bidirectional();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_GRU_SetBidirectional(PrimitivePtr *primitive, bool bidirectional) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GRU();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGRU(fbb, bidirectional);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_G_R_U), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** NonZero **********
+PrimitivePtr MindIR_NonZero_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateNonZero(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_NON_ZERO), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** InvertPermutation **********
+PrimitivePtr MindIR_InvertPermutation_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateInvertPermutation(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_INVERT_PERMUTATION), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** Size **********
+PrimitivePtr MindIR_Size_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateSize(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SIZE), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** RandomStandardNormal **********
+PrimitivePtr MindIR_RandomStandardNormal_CreatePrimitive(int64_t seed, int64_t seed2) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateRandomStandardNormal(fbb, seed, seed2);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_RANDOM_STANDARD_NORMAL), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+int64_t MindIR_RandomStandardNormal_GetSeed(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_RandomStandardNormal();
+    if (prim != nullptr && value != nullptr) {
+      return value->seed();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_RandomStandardNormal_SetSeed(PrimitivePtr *primitive, int64_t seed) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_RandomStandardNormal();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateRandomStandardNormal(fbb, seed, value->seed2());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_RANDOM_STANDARD_NORMAL), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+int64_t MindIR_RandomStandardNormal_GetSeed2(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_RandomStandardNormal();
+    if (prim != nullptr && value != nullptr) {
+      return value->seed2();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_RandomStandardNormal_SetSeed2(PrimitivePtr *primitive, int64_t seed2) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_RandomStandardNormal();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateRandomStandardNormal(fbb, value->seed(), seed2);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_RANDOM_STANDARD_NORMAL), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** CropAndResize **********
+PrimitivePtr MindIR_CropAndResize_CreatePrimitive(ResizeMethod method, float extrapolation_value) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateCropAndResize(fbb, static_cast<schema::ResizeMethod>(method), extrapolation_value);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_CROP_AND_RESIZE), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+ResizeMethod MindIR_CropAndResize_GetMethod(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_CropAndResize();
+    if (prim != nullptr && value != nullptr) {
+      return static_cast<ResizeMethod>(value->method());
+    } else {
+      ResizeMethod en = static_cast<ResizeMethod>(0);
+      return en;
+    }
+  } else {
+    ResizeMethod en = static_cast<ResizeMethod>(0);
+    return en;
+  }
+}
+
+void MindIR_CropAndResize_SetMethod(PrimitivePtr *primitive, ResizeMethod method) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_CropAndResize();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateCropAndResize(fbb, static_cast<schema::ResizeMethod>(method), value->extrapolation_value());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_CROP_AND_RESIZE), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+float MindIR_CropAndResize_GetExtrapolationValue(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_CropAndResize();
+    if (prim != nullptr && value != nullptr) {
+      return value->extrapolation_value();
+    } else {
+      return .0;
+    }
+  } else {
+    return .0;
+  }
+}
+
+void MindIR_CropAndResize_SetExtrapolationValue(PrimitivePtr *primitive, float extrapolation_value) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_CropAndResize();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateCropAndResize(fbb, static_cast<schema::ResizeMethod>(value->method()), extrapolation_value);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_CROP_AND_RESIZE), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** IsFinite **********
+PrimitivePtr MindIR_IsFinite_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateIsFinite(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_IS_FINITE), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** LinSpace **********
+PrimitivePtr MindIR_LinSpace_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateLinSpace(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_LIN_SPACE), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** UniformReal **********
+PrimitivePtr MindIR_UniformReal_CreatePrimitive(int64_t seed, int64_t seed2) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateUniformReal(fbb, seed, seed2);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_UNIFORM_REAL), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+int64_t MindIR_UniformReal_GetSeed(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_UniformReal();
+    if (prim != nullptr && value != nullptr) {
+      return value->seed();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_UniformReal_SetSeed(PrimitivePtr *primitive, int64_t seed) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_UniformReal();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateUniformReal(fbb, seed, value->seed2());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_UNIFORM_REAL), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+int64_t MindIR_UniformReal_GetSeed2(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_UniformReal();
+    if (prim != nullptr && value != nullptr) {
+      return value->seed2();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_UniformReal_SetSeed2(PrimitivePtr *primitive, int64_t seed2) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_UniformReal();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateUniformReal(fbb, value->seed(), seed2);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_UNIFORM_REAL), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** Splice **********
+PrimitivePtr MindIR_Splice_CreatePrimitive(const std::vector<int64_t> &context, const std::vector<int64_t> &forward_indexes, int64_t output_dim) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateSplice(fbb, fbb.CreateVector(context.data(), context.size()), fbb.CreateVector(forward_indexes.data(), forward_indexes.size()), output_dim);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SPLICE), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+std::vector<int64_t> MindIR_Splice_GetContext(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_Splice();
+    if (prim != nullptr && value != nullptr) {
+      std::vector<int64_t> result;
+      auto src = value->context();
+      if (src == nullptr) {
+        return {};
+      }
+      result.resize(src->size());
+      std::transform(src->begin(), src->end(), result.begin(), [](int64_t item) { return item; });
+      return result;
+    } else {
+      return {};
+    }
+  } else {
+    return {};
+  }
+}
+
+void MindIR_Splice_SetContext(PrimitivePtr *primitive, const std::vector<int64_t> &context) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_Splice();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateSplice(fbb, fbb.CreateVector(context.data(), context.size()), fbb.CreateVector(value->forward_indexes()->data(), value->forward_indexes()->size()), value->output_dim());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SPLICE), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+std::vector<int64_t> MindIR_Splice_GetForwardIndexes(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_Splice();
+    if (prim != nullptr && value != nullptr) {
+      std::vector<int64_t> result;
+      auto src = value->forward_indexes();
+      if (src == nullptr) {
+        return {};
+      }
+      result.resize(src->size());
+      std::transform(src->begin(), src->end(), result.begin(), [](int64_t item) { return item; });
+      return result;
+    } else {
+      return {};
+    }
+  } else {
+    return {};
+  }
+}
+
+void MindIR_Splice_SetForwardIndexes(PrimitivePtr *primitive, const std::vector<int64_t> &forward_indexes) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_Splice();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateSplice(fbb, fbb.CreateVector(value->context()->data(), value->context()->size()), fbb.CreateVector(forward_indexes.data(), forward_indexes.size()), value->output_dim());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SPLICE), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+int64_t MindIR_Splice_GetOutputDim(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_Splice();
+    if (prim != nullptr && value != nullptr) {
+      return value->output_dim();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_Splice_SetOutputDim(PrimitivePtr *primitive, int64_t output_dim) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_Splice();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateSplice(fbb, fbb.CreateVector(value->context()->data(), value->context()->size()), fbb.CreateVector(value->forward_indexes()->data(), value->forward_indexes()->size()), output_dim);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SPLICE), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** Call **********
+PrimitivePtr MindIR_Call_CreatePrimitive(bool is_tail_call) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateCall(fbb, is_tail_call);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_CALL), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+bool MindIR_Call_GetIsTailCall(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_Call();
+    if (prim != nullptr && value != nullptr) {
+      return value->is_tail_call();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_Call_SetIsTailCall(PrimitivePtr *primitive, bool is_tail_call) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_Call();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateCall(fbb, is_tail_call);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_CALL), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** CumSum **********
+PrimitivePtr MindIR_CumSum_CreatePrimitive(bool exclusive, bool reverse) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateCumSum(fbb, exclusive, reverse);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_CUM_SUM), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+bool MindIR_CumSum_GetExclusive(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_CumSum();
+    if (prim != nullptr && value != nullptr) {
+      return value->exclusive();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_CumSum_SetExclusive(PrimitivePtr *primitive, bool exclusive) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_CumSum();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateCumSum(fbb, exclusive, value->reverse());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_CUM_SUM), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+bool MindIR_CumSum_GetReverse(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_CumSum();
+    if (prim != nullptr && value != nullptr) {
+      return value->reverse();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_CumSum_SetReverse(PrimitivePtr *primitive, bool reverse) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_CumSum();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateCumSum(fbb, value->exclusive(), reverse);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_CUM_SUM), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+}  // namespace lite
+}  // namespace mindspore
diff --git a/mindspore/lite/mindir/src/mindir_2.cc b/mindspore/lite/mindir/src/mindir_2.cc
new file mode 100644
index 00000000..5c91b7bf
--- /dev/null
+++ b/mindspore/lite/mindir/src/mindir_2.cc
@@ -0,0 +1,2152 @@
+/**
+ * Copyright 2024 Huawei Technologies Co., Ltd
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "mindir.h"
+#include "utils.h"
+#include "schema/model_generated.h"
+#include "mindir_memory_manager.h"
+
+namespace mindspore {
+namespace lite {
+// ********** SplitWithOverlap **********
+PrimitivePtr MindIR_SplitWithOverlap_CreatePrimitive(int64_t split_dim, int64_t number_split, const std::vector<int64_t> &ratio, const std::vector<int64_t> &extend_top, const std::vector<int64_t> &extend_bottom) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateSplitWithOverlap(fbb, split_dim, number_split, fbb.CreateVector(ratio.data(), ratio.size()), fbb.CreateVector(extend_top.data(), extend_top.size()), fbb.CreateVector(extend_bottom.data(), extend_bottom.size()));
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SPLIT_WITH_OVERLAP), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+int64_t MindIR_SplitWithOverlap_GetSplitDim(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_SplitWithOverlap();
+    if (prim != nullptr && value != nullptr) {
+      return value->split_dim();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_SplitWithOverlap_SetSplitDim(PrimitivePtr *primitive, int64_t split_dim) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_SplitWithOverlap();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateSplitWithOverlap(fbb, split_dim, value->number_split(), fbb.CreateVector(value->ratio()->data(), value->ratio()->size()), fbb.CreateVector(value->extend_top()->data(), value->extend_top()->size()), fbb.CreateVector(value->extend_bottom()->data(), value->extend_bottom()->size()));
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SPLIT_WITH_OVERLAP), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+int64_t MindIR_SplitWithOverlap_GetNumberSplit(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_SplitWithOverlap();
+    if (prim != nullptr && value != nullptr) {
+      return value->number_split();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_SplitWithOverlap_SetNumberSplit(PrimitivePtr *primitive, int64_t number_split) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_SplitWithOverlap();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateSplitWithOverlap(fbb, value->split_dim(), number_split, fbb.CreateVector(value->ratio()->data(), value->ratio()->size()), fbb.CreateVector(value->extend_top()->data(), value->extend_top()->size()), fbb.CreateVector(value->extend_bottom()->data(), value->extend_bottom()->size()));
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SPLIT_WITH_OVERLAP), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+std::vector<int64_t> MindIR_SplitWithOverlap_GetRatio(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_SplitWithOverlap();
+    if (prim != nullptr && value != nullptr) {
+      std::vector<int64_t> result;
+      auto src = value->ratio();
+      if (src == nullptr) {
+        return {};
+      }
+      result.resize(src->size());
+      std::transform(src->begin(), src->end(), result.begin(), [](int64_t item) { return item; });
+      return result;
+    } else {
+      return {};
+    }
+  } else {
+    return {};
+  }
+}
+
+void MindIR_SplitWithOverlap_SetRatio(PrimitivePtr *primitive, const std::vector<int64_t> &ratio) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_SplitWithOverlap();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateSplitWithOverlap(fbb, value->split_dim(), value->number_split(), fbb.CreateVector(ratio.data(), ratio.size()), fbb.CreateVector(value->extend_top()->data(), value->extend_top()->size()), fbb.CreateVector(value->extend_bottom()->data(), value->extend_bottom()->size()));
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SPLIT_WITH_OVERLAP), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+std::vector<int64_t> MindIR_SplitWithOverlap_GetExtendTop(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_SplitWithOverlap();
+    if (prim != nullptr && value != nullptr) {
+      std::vector<int64_t> result;
+      auto src = value->extend_top();
+      if (src == nullptr) {
+        return {};
+      }
+      result.resize(src->size());
+      std::transform(src->begin(), src->end(), result.begin(), [](int64_t item) { return item; });
+      return result;
+    } else {
+      return {};
+    }
+  } else {
+    return {};
+  }
+}
+
+void MindIR_SplitWithOverlap_SetExtendTop(PrimitivePtr *primitive, const std::vector<int64_t> &extend_top) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_SplitWithOverlap();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateSplitWithOverlap(fbb, value->split_dim(), value->number_split(), fbb.CreateVector(value->ratio()->data(), value->ratio()->size()), fbb.CreateVector(extend_top.data(), extend_top.size()), fbb.CreateVector(value->extend_bottom()->data(), value->extend_bottom()->size()));
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SPLIT_WITH_OVERLAP), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+std::vector<int64_t> MindIR_SplitWithOverlap_GetExtendBottom(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_SplitWithOverlap();
+    if (prim != nullptr && value != nullptr) {
+      std::vector<int64_t> result;
+      auto src = value->extend_bottom();
+      if (src == nullptr) {
+        return {};
+      }
+      result.resize(src->size());
+      std::transform(src->begin(), src->end(), result.begin(), [](int64_t item) { return item; });
+      return result;
+    } else {
+      return {};
+    }
+  } else {
+    return {};
+  }
+}
+
+void MindIR_SplitWithOverlap_SetExtendBottom(PrimitivePtr *primitive, const std::vector<int64_t> &extend_bottom) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_SplitWithOverlap();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateSplitWithOverlap(fbb, value->split_dim(), value->number_split(), fbb.CreateVector(value->ratio()->data(), value->ratio()->size()), fbb.CreateVector(value->extend_top()->data(), value->extend_top()->size()), fbb.CreateVector(extend_bottom.data(), extend_bottom.size()));
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SPLIT_WITH_OVERLAP), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** GenOP **********
+PrimitivePtr MindIR_GenOP_CreatePrimitive(ActivationType activation_type, float alpha, float min_val, float max_val, bool is_training, Format format, const std::vector<int64_t> &kernel_size, const std::vector<int64_t> &stride, const std::vector<int64_t> &dilation, PadMode pad_mode, const std::vector<int64_t> &pad_list, int64_t mode, int64_t group, int64_t in_channel, int64_t out_channel, EltwiseMode eltwise_mode, bool has_bias, bool use_axis, int64_t axis, float epsilon, float momentum, bool transpose_a, bool transpose_b, const std::vector<int64_t> &pad, RoundMode round_mode, bool global, bool channel_shared, const std::vector<int64_t> &axes, bool keep_dims, ReduceMode reduce_mode, bool reduce_to_end, float coeff) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(activation_type), alpha, min_val, max_val, is_training, static_cast<schema::Format>(format), fbb.CreateVector(kernel_size.data(), kernel_size.size()), fbb.CreateVector(stride.data(), stride.size()), fbb.CreateVector(dilation.data(), dilation.size()), static_cast<schema::PadMode>(pad_mode), fbb.CreateVector(pad_list.data(), pad_list.size()), mode, group, in_channel, out_channel, static_cast<schema::EltwiseMode>(eltwise_mode), has_bias, use_axis, axis, epsilon, momentum, transpose_a, transpose_b, fbb.CreateVector(pad.data(), pad.size()), static_cast<schema::RoundMode>(round_mode), global, channel_shared, fbb.CreateVector(axes.data(), axes.size()), keep_dims, static_cast<schema::ReduceMode>(reduce_mode), reduce_to_end, coeff);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+ActivationType MindIR_GenOP_GetActivationType(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return static_cast<ActivationType>(value->activation_type());
+    } else {
+      ActivationType en = static_cast<ActivationType>(0);
+      return en;
+    }
+  } else {
+    ActivationType en = static_cast<ActivationType>(0);
+    return en;
+  }
+}
+
+void MindIR_GenOP_SetActivationType(PrimitivePtr *primitive, ActivationType activation_type) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(activation_type), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+float MindIR_GenOP_GetAlpha(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return value->alpha();
+    } else {
+      return .0;
+    }
+  } else {
+    return .0;
+  }
+}
+
+void MindIR_GenOP_SetAlpha(PrimitivePtr *primitive, float alpha) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), alpha, value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+float MindIR_GenOP_GetMinVal(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return value->min_val();
+    } else {
+      return .0;
+    }
+  } else {
+    return .0;
+  }
+}
+
+void MindIR_GenOP_SetMinVal(PrimitivePtr *primitive, float min_val) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), min_val, value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+float MindIR_GenOP_GetMaxVal(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return value->max_val();
+    } else {
+      return .0;
+    }
+  } else {
+    return .0;
+  }
+}
+
+void MindIR_GenOP_SetMaxVal(PrimitivePtr *primitive, float max_val) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), max_val, value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+bool MindIR_GenOP_GetIsTraining(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return value->is_training();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_GenOP_SetIsTraining(PrimitivePtr *primitive, bool is_training) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), is_training, static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+Format MindIR_GenOP_GetFormat(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return static_cast<Format>(value->format());
+    } else {
+      Format en = static_cast<Format>(0);
+      return en;
+    }
+  } else {
+    Format en = static_cast<Format>(0);
+    return en;
+  }
+}
+
+void MindIR_GenOP_SetFormat(PrimitivePtr *primitive, Format format) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(format), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+std::vector<int64_t> MindIR_GenOP_GetKernelSize(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      std::vector<int64_t> result;
+      auto src = value->kernel_size();
+      if (src == nullptr) {
+        return {};
+      }
+      result.resize(src->size());
+      std::transform(src->begin(), src->end(), result.begin(), [](int64_t item) { return item; });
+      return result;
+    } else {
+      return {};
+    }
+  } else {
+    return {};
+  }
+}
+
+void MindIR_GenOP_SetKernelSize(PrimitivePtr *primitive, const std::vector<int64_t> &kernel_size) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(kernel_size.data(), kernel_size.size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+std::vector<int64_t> MindIR_GenOP_GetStride(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      std::vector<int64_t> result;
+      auto src = value->stride();
+      if (src == nullptr) {
+        return {};
+      }
+      result.resize(src->size());
+      std::transform(src->begin(), src->end(), result.begin(), [](int64_t item) { return item; });
+      return result;
+    } else {
+      return {};
+    }
+  } else {
+    return {};
+  }
+}
+
+void MindIR_GenOP_SetStride(PrimitivePtr *primitive, const std::vector<int64_t> &stride) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(stride.data(), stride.size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+std::vector<int64_t> MindIR_GenOP_GetDilation(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      std::vector<int64_t> result;
+      auto src = value->dilation();
+      if (src == nullptr) {
+        return {};
+      }
+      result.resize(src->size());
+      std::transform(src->begin(), src->end(), result.begin(), [](int64_t item) { return item; });
+      return result;
+    } else {
+      return {};
+    }
+  } else {
+    return {};
+  }
+}
+
+void MindIR_GenOP_SetDilation(PrimitivePtr *primitive, const std::vector<int64_t> &dilation) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(dilation.data(), dilation.size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+PadMode MindIR_GenOP_GetPadMode(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return static_cast<PadMode>(value->pad_mode());
+    } else {
+      PadMode en = static_cast<PadMode>(0);
+      return en;
+    }
+  } else {
+    PadMode en = static_cast<PadMode>(0);
+    return en;
+  }
+}
+
+void MindIR_GenOP_SetPadMode(PrimitivePtr *primitive, PadMode pad_mode) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(pad_mode), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+std::vector<int64_t> MindIR_GenOP_GetPadList(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      std::vector<int64_t> result;
+      auto src = value->pad_list();
+      if (src == nullptr) {
+        return {};
+      }
+      result.resize(src->size());
+      std::transform(src->begin(), src->end(), result.begin(), [](int64_t item) { return item; });
+      return result;
+    } else {
+      return {};
+    }
+  } else {
+    return {};
+  }
+}
+
+void MindIR_GenOP_SetPadList(PrimitivePtr *primitive, const std::vector<int64_t> &pad_list) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(pad_list.data(), pad_list.size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+int64_t MindIR_GenOP_GetMode(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return value->mode();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_GenOP_SetMode(PrimitivePtr *primitive, int64_t mode) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), mode, value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+int64_t MindIR_GenOP_GetGroup(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return value->group();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_GenOP_SetGroup(PrimitivePtr *primitive, int64_t group) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), group, value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+int64_t MindIR_GenOP_GetInChannel(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return value->in_channel();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_GenOP_SetInChannel(PrimitivePtr *primitive, int64_t in_channel) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), in_channel, value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+int64_t MindIR_GenOP_GetOutChannel(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return value->out_channel();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_GenOP_SetOutChannel(PrimitivePtr *primitive, int64_t out_channel) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), out_channel, static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+EltwiseMode MindIR_GenOP_GetEltwiseMode(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return static_cast<EltwiseMode>(value->eltwise_mode());
+    } else {
+      EltwiseMode en = static_cast<EltwiseMode>(0);
+      return en;
+    }
+  } else {
+    EltwiseMode en = static_cast<EltwiseMode>(0);
+    return en;
+  }
+}
+
+void MindIR_GenOP_SetEltwiseMode(PrimitivePtr *primitive, EltwiseMode eltwise_mode) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(eltwise_mode), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+bool MindIR_GenOP_GetHasBias(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return value->has_bias();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_GenOP_SetHasBias(PrimitivePtr *primitive, bool has_bias) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), has_bias, value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+bool MindIR_GenOP_GetUseAxis(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return value->use_axis();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_GenOP_SetUseAxis(PrimitivePtr *primitive, bool use_axis) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), use_axis, value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+int64_t MindIR_GenOP_GetAxis(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return value->axis();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_GenOP_SetAxis(PrimitivePtr *primitive, int64_t axis) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), axis, value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+float MindIR_GenOP_GetEpsilon(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return value->epsilon();
+    } else {
+      return .0;
+    }
+  } else {
+    return .0;
+  }
+}
+
+void MindIR_GenOP_SetEpsilon(PrimitivePtr *primitive, float epsilon) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), epsilon, value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+float MindIR_GenOP_GetMomentum(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return value->momentum();
+    } else {
+      return .0;
+    }
+  } else {
+    return .0;
+  }
+}
+
+void MindIR_GenOP_SetMomentum(PrimitivePtr *primitive, float momentum) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), momentum, value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+bool MindIR_GenOP_GetTransposeA(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return value->transpose_a();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_GenOP_SetTransposeA(PrimitivePtr *primitive, bool transpose_a) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), transpose_a, value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+bool MindIR_GenOP_GetTransposeB(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return value->transpose_b();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_GenOP_SetTransposeB(PrimitivePtr *primitive, bool transpose_b) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), transpose_b, fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+std::vector<int64_t> MindIR_GenOP_GetPad(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      std::vector<int64_t> result;
+      auto src = value->pad();
+      if (src == nullptr) {
+        return {};
+      }
+      result.resize(src->size());
+      std::transform(src->begin(), src->end(), result.begin(), [](int64_t item) { return item; });
+      return result;
+    } else {
+      return {};
+    }
+  } else {
+    return {};
+  }
+}
+
+void MindIR_GenOP_SetPad(PrimitivePtr *primitive, const std::vector<int64_t> &pad) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(pad.data(), pad.size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+RoundMode MindIR_GenOP_GetRoundMode(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return static_cast<RoundMode>(value->round_mode());
+    } else {
+      RoundMode en = static_cast<RoundMode>(0);
+      return en;
+    }
+  } else {
+    RoundMode en = static_cast<RoundMode>(0);
+    return en;
+  }
+}
+
+void MindIR_GenOP_SetRoundMode(PrimitivePtr *primitive, RoundMode round_mode) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(round_mode), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+bool MindIR_GenOP_GetGlobal(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return value->global();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_GenOP_SetGlobal(PrimitivePtr *primitive, bool global) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), global, value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+bool MindIR_GenOP_GetChannelShared(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return value->channel_shared();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_GenOP_SetChannelShared(PrimitivePtr *primitive, bool channel_shared) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), channel_shared, fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+std::vector<int64_t> MindIR_GenOP_GetAxes(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      std::vector<int64_t> result;
+      auto src = value->axes();
+      if (src == nullptr) {
+        return {};
+      }
+      result.resize(src->size());
+      std::transform(src->begin(), src->end(), result.begin(), [](int64_t item) { return item; });
+      return result;
+    } else {
+      return {};
+    }
+  } else {
+    return {};
+  }
+}
+
+void MindIR_GenOP_SetAxes(PrimitivePtr *primitive, const std::vector<int64_t> &axes) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(axes.data(), axes.size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+bool MindIR_GenOP_GetKeepDims(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return value->keep_dims();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_GenOP_SetKeepDims(PrimitivePtr *primitive, bool keep_dims) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), keep_dims, static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+ReduceMode MindIR_GenOP_GetReduceMode(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return static_cast<ReduceMode>(value->reduce_mode());
+    } else {
+      ReduceMode en = static_cast<ReduceMode>(0);
+      return en;
+    }
+  } else {
+    ReduceMode en = static_cast<ReduceMode>(0);
+    return en;
+  }
+}
+
+void MindIR_GenOP_SetReduceMode(PrimitivePtr *primitive, ReduceMode reduce_mode) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(reduce_mode), value->reduce_to_end(), value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+bool MindIR_GenOP_GetReduceToEnd(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return value->reduce_to_end();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_GenOP_SetReduceToEnd(PrimitivePtr *primitive, bool reduce_to_end) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), reduce_to_end, value->coeff());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+float MindIR_GenOP_GetCoeff(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      return value->coeff();
+    } else {
+      return .0;
+    }
+  } else {
+    return .0;
+  }
+}
+
+void MindIR_GenOP_SetCoeff(PrimitivePtr *primitive, float coeff) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GenOP();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGenOP(fbb, static_cast<schema::ActivationType>(value->activation_type()), value->alpha(), value->min_val(), value->max_val(), value->is_training(), static_cast<schema::Format>(value->format()), fbb.CreateVector(value->kernel_size()->data(), value->kernel_size()->size()), fbb.CreateVector(value->stride()->data(), value->stride()->size()), fbb.CreateVector(value->dilation()->data(), value->dilation()->size()), static_cast<schema::PadMode>(value->pad_mode()), fbb.CreateVector(value->pad_list()->data(), value->pad_list()->size()), value->mode(), value->group(), value->in_channel(), value->out_channel(), static_cast<schema::EltwiseMode>(value->eltwise_mode()), value->has_bias(), value->use_axis(), value->axis(), value->epsilon(), value->momentum(), value->transpose_a(), value->transpose_b(), fbb.CreateVector(value->pad()->data(), value->pad()->size()), static_cast<schema::RoundMode>(value->round_mode()), value->global(), value->channel_shared(), fbb.CreateVector(value->axes()->data(), value->axes()->size()), value->keep_dims(), static_cast<schema::ReduceMode>(value->reduce_mode()), value->reduce_to_end(), coeff);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GEN_O_P), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** RaggedRange **********
+PrimitivePtr MindIR_RaggedRange_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateRaggedRange(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_RAGGED_RANGE), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** GLU **********
+PrimitivePtr MindIR_GLU_CreatePrimitive(int64_t axis) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateGLU(fbb, axis);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_G_L_U), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+int64_t MindIR_GLU_GetAxis(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GLU();
+    if (prim != nullptr && value != nullptr) {
+      return value->axis();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_GLU_SetAxis(PrimitivePtr *primitive, int64_t axis) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GLU();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGLU(fbb, axis);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_G_L_U), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** Affine **********
+PrimitivePtr MindIR_Affine_CreatePrimitive(const std::vector<int64_t> &context, int64_t output_dim, ActivationType activation_type, bool transpose_a, bool transpose_b) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateAffine(fbb, fbb.CreateVector(context.data(), context.size()), output_dim, static_cast<schema::ActivationType>(activation_type), transpose_a, transpose_b);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_AFFINE), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+std::vector<int64_t> MindIR_Affine_GetContext(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_Affine();
+    if (prim != nullptr && value != nullptr) {
+      std::vector<int64_t> result;
+      auto src = value->context();
+      if (src == nullptr) {
+        return {};
+      }
+      result.resize(src->size());
+      std::transform(src->begin(), src->end(), result.begin(), [](int64_t item) { return item; });
+      return result;
+    } else {
+      return {};
+    }
+  } else {
+    return {};
+  }
+}
+
+void MindIR_Affine_SetContext(PrimitivePtr *primitive, const std::vector<int64_t> &context) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_Affine();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateAffine(fbb, fbb.CreateVector(context.data(), context.size()), value->output_dim(), static_cast<schema::ActivationType>(value->activation_type()), value->transpose_a(), value->transpose_b());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_AFFINE), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+int64_t MindIR_Affine_GetOutputDim(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_Affine();
+    if (prim != nullptr && value != nullptr) {
+      return value->output_dim();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_Affine_SetOutputDim(PrimitivePtr *primitive, int64_t output_dim) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_Affine();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateAffine(fbb, fbb.CreateVector(value->context()->data(), value->context()->size()), output_dim, static_cast<schema::ActivationType>(value->activation_type()), value->transpose_a(), value->transpose_b());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_AFFINE), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+ActivationType MindIR_Affine_GetActivationType(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_Affine();
+    if (prim != nullptr && value != nullptr) {
+      return static_cast<ActivationType>(value->activation_type());
+    } else {
+      ActivationType en = static_cast<ActivationType>(0);
+      return en;
+    }
+  } else {
+    ActivationType en = static_cast<ActivationType>(0);
+    return en;
+  }
+}
+
+void MindIR_Affine_SetActivationType(PrimitivePtr *primitive, ActivationType activation_type) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_Affine();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateAffine(fbb, fbb.CreateVector(value->context()->data(), value->context()->size()), value->output_dim(), static_cast<schema::ActivationType>(activation_type), value->transpose_a(), value->transpose_b());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_AFFINE), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+bool MindIR_Affine_GetTransposeA(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_Affine();
+    if (prim != nullptr && value != nullptr) {
+      return value->transpose_a();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_Affine_SetTransposeA(PrimitivePtr *primitive, bool transpose_a) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_Affine();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateAffine(fbb, fbb.CreateVector(value->context()->data(), value->context()->size()), value->output_dim(), static_cast<schema::ActivationType>(value->activation_type()), transpose_a, value->transpose_b());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_AFFINE), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+bool MindIR_Affine_GetTransposeB(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_Affine();
+    if (prim != nullptr && value != nullptr) {
+      return value->transpose_b();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_Affine_SetTransposeB(PrimitivePtr *primitive, bool transpose_b) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_Affine();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateAffine(fbb, fbb.CreateVector(value->context()->data(), value->context()->size()), value->output_dim(), static_cast<schema::ActivationType>(value->activation_type()), value->transpose_a(), transpose_b);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_AFFINE), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** AllGather **********
+PrimitivePtr MindIR_AllGather_CreatePrimitive(const std::string &group, int32_t rank_size) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateAllGather(fbb, fbb.CreateString(group), rank_size);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_ALL_GATHER), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+std::string MindIR_AllGather_GetGroup(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_AllGather();
+    if (prim != nullptr && value != nullptr) {
+      return std::string(value->group()->c_str(),value->group()->size());
+    } else {
+      return "";
+    }
+  } else {
+    return "";
+  }
+}
+
+void MindIR_AllGather_SetGroup(PrimitivePtr *primitive, const std::string &group) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_AllGather();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateAllGather(fbb, fbb.CreateString(group), value->rank_size());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_ALL_GATHER), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+int32_t MindIR_AllGather_GetRankSize(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_AllGather();
+    if (prim != nullptr && value != nullptr) {
+      return value->rank_size();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_AllGather_SetRankSize(PrimitivePtr *primitive, int32_t rank_size) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_AllGather();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateAllGather(fbb, fbb.CreateString(std::string(value->group()->c_str(), value->group()->size())), rank_size);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_ALL_GATHER), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** ReduceScatter **********
+PrimitivePtr MindIR_ReduceScatter_CreatePrimitive(const std::string &group, ReduceMode mode, int32_t rank_size) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateReduceScatter(fbb, fbb.CreateString(group), static_cast<schema::ReduceMode>(mode), rank_size);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_REDUCE_SCATTER), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+std::string MindIR_ReduceScatter_GetGroup(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_ReduceScatter();
+    if (prim != nullptr && value != nullptr) {
+      return std::string(value->group()->c_str(),value->group()->size());
+    } else {
+      return "";
+    }
+  } else {
+    return "";
+  }
+}
+
+void MindIR_ReduceScatter_SetGroup(PrimitivePtr *primitive, const std::string &group) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_ReduceScatter();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateReduceScatter(fbb, fbb.CreateString(group), static_cast<schema::ReduceMode>(value->mode()), value->rank_size());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_REDUCE_SCATTER), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+ReduceMode MindIR_ReduceScatter_GetMode(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_ReduceScatter();
+    if (prim != nullptr && value != nullptr) {
+      return static_cast<ReduceMode>(value->mode());
+    } else {
+      ReduceMode en = static_cast<ReduceMode>(0);
+      return en;
+    }
+  } else {
+    ReduceMode en = static_cast<ReduceMode>(0);
+    return en;
+  }
+}
+
+void MindIR_ReduceScatter_SetMode(PrimitivePtr *primitive, ReduceMode mode) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_ReduceScatter();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateReduceScatter(fbb, fbb.CreateString(std::string(value->group()->c_str(), value->group()->size())), static_cast<schema::ReduceMode>(mode), value->rank_size());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_REDUCE_SCATTER), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+int32_t MindIR_ReduceScatter_GetRankSize(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_ReduceScatter();
+    if (prim != nullptr && value != nullptr) {
+      return value->rank_size();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_ReduceScatter_SetRankSize(PrimitivePtr *primitive, int32_t rank_size) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_ReduceScatter();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateReduceScatter(fbb, fbb.CreateString(std::string(value->group()->c_str(), value->group()->size())), static_cast<schema::ReduceMode>(value->mode()), rank_size);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_REDUCE_SCATTER), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** DynamicQuant **********
+PrimitivePtr MindIR_DynamicQuant_CreatePrimitive(bool symmetric, int64_t dst_type) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateDynamicQuant(fbb, symmetric, dst_type);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_DYNAMIC_QUANT), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+bool MindIR_DynamicQuant_GetSymmetric(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_DynamicQuant();
+    if (prim != nullptr && value != nullptr) {
+      return value->symmetric();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_DynamicQuant_SetSymmetric(PrimitivePtr *primitive, bool symmetric) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_DynamicQuant();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateDynamicQuant(fbb, symmetric, value->dst_type());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_DYNAMIC_QUANT), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+int64_t MindIR_DynamicQuant_GetDstType(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_DynamicQuant();
+    if (prim != nullptr && value != nullptr) {
+      return value->dst_type();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_DynamicQuant_SetDstType(PrimitivePtr *primitive, int64_t dst_type) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_DynamicQuant();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateDynamicQuant(fbb, value->symmetric(), dst_type);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_DYNAMIC_QUANT), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** RandomNormal **********
+PrimitivePtr MindIR_RandomNormal_CreatePrimitive(float seed, float mean, float scale) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateRandomNormal(fbb, seed, mean, scale);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_RANDOM_NORMAL), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+float MindIR_RandomNormal_GetSeed(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_RandomNormal();
+    if (prim != nullptr && value != nullptr) {
+      return value->seed();
+    } else {
+      return .0;
+    }
+  } else {
+    return .0;
+  }
+}
+
+void MindIR_RandomNormal_SetSeed(PrimitivePtr *primitive, float seed) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_RandomNormal();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateRandomNormal(fbb, seed, value->mean(), value->scale());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_RANDOM_NORMAL), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+float MindIR_RandomNormal_GetMean(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_RandomNormal();
+    if (prim != nullptr && value != nullptr) {
+      return value->mean();
+    } else {
+      return .0;
+    }
+  } else {
+    return .0;
+  }
+}
+
+void MindIR_RandomNormal_SetMean(PrimitivePtr *primitive, float mean) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_RandomNormal();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateRandomNormal(fbb, value->seed(), mean, value->scale());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_RANDOM_NORMAL), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+float MindIR_RandomNormal_GetScale(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_RandomNormal();
+    if (prim != nullptr && value != nullptr) {
+      return value->scale();
+    } else {
+      return .0;
+    }
+  } else {
+    return .0;
+  }
+}
+
+void MindIR_RandomNormal_SetScale(PrimitivePtr *primitive, float scale) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_RandomNormal();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateRandomNormal(fbb, value->seed(), value->mean(), scale);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_RANDOM_NORMAL), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** FormatTranspose **********
+PrimitivePtr MindIR_FormatTranspose_CreatePrimitive(Format src_format, Format dst_format) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateFormatTranspose(fbb, static_cast<schema::Format>(src_format), static_cast<schema::Format>(dst_format));
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_FORMAT_TRANSPOSE), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+Format MindIR_FormatTranspose_GetSrcFormat(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_FormatTranspose();
+    if (prim != nullptr && value != nullptr) {
+      return static_cast<Format>(value->src_format());
+    } else {
+      Format en = static_cast<Format>(0);
+      return en;
+    }
+  } else {
+    Format en = static_cast<Format>(0);
+    return en;
+  }
+}
+
+void MindIR_FormatTranspose_SetSrcFormat(PrimitivePtr *primitive, Format src_format) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_FormatTranspose();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateFormatTranspose(fbb, static_cast<schema::Format>(src_format), static_cast<schema::Format>(value->dst_format()));
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_FORMAT_TRANSPOSE), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+Format MindIR_FormatTranspose_GetDstFormat(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_FormatTranspose();
+    if (prim != nullptr && value != nullptr) {
+      return static_cast<Format>(value->dst_format());
+    } else {
+      Format en = static_cast<Format>(0);
+      return en;
+    }
+  } else {
+    Format en = static_cast<Format>(0);
+    return en;
+  }
+}
+
+void MindIR_FormatTranspose_SetDstFormat(PrimitivePtr *primitive, Format dst_format) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_FormatTranspose();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateFormatTranspose(fbb, static_cast<schema::Format>(value->src_format()), static_cast<schema::Format>(dst_format));
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_FORMAT_TRANSPOSE), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** GatherD **********
+PrimitivePtr MindIR_GatherD_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateGatherD(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GATHER_D), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** GroupNormFusion **********
+PrimitivePtr MindIR_GroupNormFusion_CreatePrimitive(int64_t num_groups, float epsilon, bool affine) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateGroupNormFusion(fbb, num_groups, epsilon, affine);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GROUP_NORM_FUSION), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+int64_t MindIR_GroupNormFusion_GetNumGroups(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GroupNormFusion();
+    if (prim != nullptr && value != nullptr) {
+      return value->num_groups();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_GroupNormFusion_SetNumGroups(PrimitivePtr *primitive, int64_t num_groups) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GroupNormFusion();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGroupNormFusion(fbb, num_groups, value->epsilon(), value->affine());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GROUP_NORM_FUSION), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+float MindIR_GroupNormFusion_GetEpsilon(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GroupNormFusion();
+    if (prim != nullptr && value != nullptr) {
+      return value->epsilon();
+    } else {
+      return .0;
+    }
+  } else {
+    return .0;
+  }
+}
+
+void MindIR_GroupNormFusion_SetEpsilon(PrimitivePtr *primitive, float epsilon) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GroupNormFusion();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGroupNormFusion(fbb, value->num_groups(), epsilon, value->affine());
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GROUP_NORM_FUSION), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+bool MindIR_GroupNormFusion_GetAffine(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_GroupNormFusion();
+    if (prim != nullptr && value != nullptr) {
+      return value->affine();
+    } else {
+      return false;
+    }
+  } else {
+    return false;
+  }
+}
+
+void MindIR_GroupNormFusion_SetAffine(PrimitivePtr *primitive, bool affine) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_GroupNormFusion();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateGroupNormFusion(fbb, value->num_groups(), value->epsilon(), affine);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_GROUP_NORM_FUSION), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** Log1p **********
+PrimitivePtr MindIR_Log1p_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateLog1p(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_LOG1P), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** SparseFillEmptyRows **********
+PrimitivePtr MindIR_SparseFillEmptyRows_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateSparseFillEmptyRows(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SPARSE_FILL_EMPTY_ROWS), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** SparseReshape **********
+PrimitivePtr MindIR_SparseReshape_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateSparseReshape(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SPARSE_RESHAPE), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** SparseSegmentSum **********
+PrimitivePtr MindIR_SparseSegmentSum_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateSparseSegmentSum(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SPARSE_SEGMENT_SUM), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** ScatterElements **********
+PrimitivePtr MindIR_ScatterElements_CreatePrimitive(int64_t axis) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateScatterElements(fbb, axis);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SCATTER_ELEMENTS), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+int64_t MindIR_ScatterElements_GetAxis(ConstPrimitivePtr primitive) {
+  if (primitive != nullptr) {
+    auto prim = static_cast<const schema::Primitive *>(primitive);
+    auto value = prim->value_as_ScatterElements();
+    if (prim != nullptr && value != nullptr) {
+      return value->axis();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
+void MindIR_ScatterElements_SetAxis(PrimitivePtr *primitive, int64_t axis) {
+  if (primitive != nullptr && *primitive != nullptr) {
+    auto prim = static_cast<schema::Primitive *>(*primitive);
+    auto value = prim->value_as_ScatterElements();
+    if (prim != nullptr && value != nullptr) {
+      flatbuffers::FlatBufferBuilder fbb;
+      auto ops_offset = schema::CreateScatterElements(fbb, axis);
+      auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_SCATTER_ELEMENTS), ops_offset.o);
+      fbb.Finish(prim_offset);
+      auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+      auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+      free(*primitive);
+      *primitive = ret_value;
+    }
+  }
+}
+
+// ********** Triu **********
+PrimitivePtr MindIR_Triu_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateTriu(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_TRIU), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+
+// ********** Tril **********
+PrimitivePtr MindIR_Tril_CreatePrimitive() {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto ops_offset = schema::CreateTril(fbb);
+  auto prim_offset = schema::CreatePrimitive(fbb, static_cast<schema::PrimitiveType>(NODE_TYPE_TRIL), ops_offset.o);
+  fbb.Finish(prim_offset);
+  auto new_addr = MindIRMemoryManager::GetInstance()->CreatePrimitiveFromBuilder(fbb, nullptr);
+  auto ret_value = flatbuffers::GetMutableRoot<schema::Primitive>(new_addr);
+  return ret_value;
+}
+}  // namespace lite
+}  // namespace mindspore
diff --git a/mindspore/lite/mindir/src/mindir_tensor.cc b/mindspore/lite/mindir/src/mindir_tensor.cc
index 8888e2c9..0e6a631e 100644
--- a/mindspore/lite/mindir/src/mindir_tensor.cc
+++ b/mindspore/lite/mindir/src/mindir_tensor.cc
@@ -341,6 +341,19 @@ void MindIR_Tensor_SetQuantParams(TensorPtr *tensor, const std::vector<QuantPara
   }
 }
 
+int32_t MindIR_Tensor_GetNodeType(ConstTensorPtr tensor) {
+  if (tensor != nullptr) {
+    auto value = static_cast<const schema::Tensor *>(tensor);
+    if (value != nullptr) {
+      return value->nodeType();
+    } else {
+      return 0;
+    }
+  } else {
+    return 0;
+  }
+}
+
 void MindIR_Tensor_Destroy(TensorPtr *tensor) {
   if (tensor != nullptr && *tensor != nullptr) {
     auto schema = static_cast<schema::Tensor *>(*tensor);
-- 
2.17.1

